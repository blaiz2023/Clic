unit Clic10;
//## ==========================================================================================================================================================================================================================
//##
//## MIT License
//##
//## Copyright 2025 Blaiz Enterprises ( http://www.blaizenterprises.com )
//##
//## Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
//## files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
//## modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
//## is furnished to do so, subject to the following conditions:
//##
//## The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//##
//## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//## OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
//## LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OfF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//## CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//##
//## ==========================================================================================================================================================================================================================

//##############################################################################
//## Name: Graphic Manipulation
//## Desciption: Collection of Graphic Malipulation Routines
//##
//##  OBJECTS:
//##
//## ===================================================================================
//## | Name          | Base Type   | Version   | Date       | Desciption
//## |---------------|-------------|-----------|------------|-----------------------
//## | Textures      | Tep Images  | 1.00.022  | 25/04/2002 | Texture Images
//## | Cls           | Routine     | 1.00.001  | 01/01/2002 | Fill Image with white
//## | ClsColor      | Routine     | 1.00.002  | 01/01/2002 | Fill Image with specified color
//## | Flip          | Routine     | 1.00.001  | 01/01/2002 | Vertically Flip Image
//## | Mirror        | Routine     | 1.00.001  | 01/01/2002 | Horizontally Flip Image
//## |*Rotate        | Routine     | 1.00.001  | 01/01/2002 | Rotate Image +-/0,90,180,270 degrees
//## |*Rotate90      | Routine     | 1.00.015  | 02/01/2002 | Rotate Image +90 degrees
//## |*Invert        | Routine     | 1.00.005  | 28/04/2002 | Invert Image
//## |*InvertRGB     | Routine     | 1.00.004  | 01/01/2002 | Invert Image R,G,B components
//## |*ProcessArea   | Routine     | 1.00.037  | 01/06/2002 | Image Area Processor
//## |---------------|-------------|-----------|------------|-----------------------
//## | Pixel Processors:
//## |---------------|-------------|-----------|------------|-----------------------
//## | cwInvert      | Routine     | 1.00.002  | 01/01/2002 | Pixel Processor - Invert Color
//## | cwShift       | Routine     | 1.00.005  | 01/01/2002 | Pixel Processor - Shift R,G or B Color Components
//## | cwColor       | Routine     | 1.00.001  | 01/01/2002 | Pixel Processor - Replace Color
//## | cwGreyScale   | Routine     | 1.00.003  | 01/01/2002 | Pixel Processor - Replace with GreyScale Color
//## | cwBlend       | Routine     | 1.00.005  | 01/01/2002 | Pixel Processor - Blend Color with Provided Color
//## | cwMerge       | Routine     | 1.00.007  | 01/01/2002 | Pixel Processor - Merge Color with Provided Color
//## | cwLighten     | Routine     | 1.00.005  | 01/01/2002 | Pixel Processor - Change Color R,G,B by X
//## | cwBlur        | Routine     | 1.00.011  | 01/01/2002 | Pixel Processor - Blur Current Pixel
//## |---------------|-------------|-----------|------------|-----------------------
//## | Pen Shape Processors:
//## |---------------|-------------|-----------|------------|-----------------------
//## | psCircle      | Routine     | 1.00.001  | 01/01/2002 | Pen Shape Processor - Circle within square
//## |---------------|-------------|-----------|------------|-----------------------
//## | TPenRef             | TComponent  | 1.00.022  | 07/01/2002 | Graphic Pen Controller (max dimensions 65536Wx256H)
//## ===================================================================================
//##
//## Number of Routines: 17
//## Version: 1.00.107
//## Date: 28/04/2002
//## Note: * denotes image may/is transformed to 24bit pixel
//## Lines: 2274
//## Copyright (c) 1997 - 2002 Blaiz Enterprises
//##############################################################################

Interface

Uses
  Forms, Windows, SysUtils, Classes, Graphics, Dialogs,
  Math, Controls, Clic5, Clic9, clic11;

{TIntTriplet}
Type TIntTriplet=Array[0..2] of Integer;

{Image Cursors}
Const
     crNil=1;
     crCrossHair=2;
     crPencil=3;
     crBrush=4;
     crHand=5;
     crPotFill=6;
     crGlobalPotFill=7;
     crSelect=8;
     crZoom=9;
     crShape=10;

//####### B/W and GreyScale Textures ###########

Const
{Small Textures B/W}
 ttSolid='T13003000000~'+'00#';
 ttCircles='T1G00G00))))0000~'+'ymZV(z))))))))))(v7Fym3F(vt))))))))))xdVymp#';
 ttHorzStripes='T1800800))))0000~'+'0yF0))F0)30#';
 ttVertStripes='T1800800))))0000~'+'QfbMQfbMQfb#';
 ttWeave='T1800800))))0000~'+'QzlM))lM)hb#';
 ttGrid='T16006000000))))~'+'0I00I0#';
 ttCheck='T1600200))))0000~'+'gL#';
 ttFDiagonal='T1600600))))0000~'+'I9aI9a#';
 ttBDiagonal='T1600600))))0000~'+'Ia9Ia9#';
 ttCross='T13003000000))))~'+'E9#';
 ttHorizontal='T1100F000000))l)~'+'sss#';
 ttVertical='T1F00100))))0000~'+'aaa#';
 ttBThatch='T1600600))))0000~'+'sjRsjR#';
 ttFThatch='T16006000000))))~'+'aI9aI9#';
 //Shades
ttGreys='T6020020WZBuWVyxlVCylVyxV3BqV3xpFZwlF3AiFZ9i0Zvh039e0Zvd03whGZwplZy)WVytVVBqG)AqWVCyWVCuF3wlm(8a)U9eF3whVZwlGZAm)29i0ZvlFZAmG3xpV3Bul)xt)3DylZBu))yxVZwpVZxtmVCyl)Cu03vhVZxpmUuZG3AmWVBqm2uVlZxxmZCumY8eG3BmlVCu039aWZxxW3xtG3wpW3xpG3xtGZwtFZvhm)y)V3BmG3Ai~'+'012231044567899AB9BC76D501323222E22232213110F0GGGG444H4GG02222IEEE2222J4HK6CALMNOPOK7CQ9ABBA9A889B999897R7SDT44G0022E22FUGGGGGV0112W1X0G5P779AMMABM977K5G0Y231WEWE323213311J000GG444G4GH012W2I2EEE232W104Z77MLLB7O5PKR8M99BMB88999797877SPD4T4GaF0222W100a'+'GGGGGJ01b231G4Z6799MLLABL97CKK402W32EEEc2EcI213110J1000G044GGG02WEE32EW3312233VHPR9AML76ZOD7RC99B9BCd88787R6KZTZ4eGG4000122E21FaFGG4GV03IE30G4K69AMLLLLMABAC8KD4V12EW23213IE33301310F00G0G0G0UJ3WcE2IWI20302W3J45K8MLMA7Z5DZKK7899887R7KKOKZD544eG440G0000'+'2EE30FUGGGG001E2304O78ALLfLfLALAMACCKgG0322313131c1313113X100F0UG0aF02E3WE31EWI0101333hD79MMM8PZ445ZKK7K766Kg444H444G4G4GH444G002Ec21FUaG0G001E2J44D89LLfifffLLAALAAR6ZGJ1111JJ0F0F0002111j1000J0J0J12c2Ec21EE230J002kJhPRClACK5hG44DmPPPPD54H400G0V44444D'+
'ZD44GF0EEc10FUG00013I2J4Z7CLLfififfLfLLLAMACK54V0X0G0G0GUa00111X33I2I010111E223E23EcE20100033JG5K8MACK4hV444e4T54G0X00J0V444ZPKDKDPTGU0EcE11F0F0003IE3J4OR9LiiiiiiffLLLfLLBAC6Z444GG4444G0UaFX03132I3II2222EW12E3E12EWI01001bknGDQMMA8PhGVGJ0GG0V131X0FG44'+'5DP7K6KPPD4G02E2310000013IWF44K8LLiiiiiiiffLffffoLM96KZZZPPPDD44eG0UJX131IEEW2EEEW22132EcIWIW210000133VK7LM97644JV032n13nXF0G4ZDP76R7866KD4G03EW10001p112E214479AfiiiiiifffLfifLffLB878777KKODP4444e00F1X22EW22EWIIE21I3EW02222001001b1Vm9LMM7O4hG01nX110V'+'U4TPKK97C89987KD5G03EE32110I332W1F4Z8BffiiiiiifffffLiLiLfBLMAMCd877K6PPODDZ4hG0132EEEWI2222131E22IEE3I1p00132k57MMMBCR44Gq0000h45PK6C999BMB997PP5G03EcEEc2I3IE23FG4P8AfiiiiiiffiLLLLLiLiffffLMAAB9897877K7KTZ5GGFF2c2W233113p3IEE333EW03100112VFPBMMMOPK4H'+'4GH4DPPK799AMoMBM9976P4GJ13IW2E3EcE23JGG569AfiiiiiilflLLLLLLfLfLiffLLALABA9BCACR67OPPT4GG1J32W222313IW2cI12E213p10323J5CAML9C6K4r4gK677C9AMLLMAL9B776O440112W2cEEW2E1FG4K6dAfiiiiilflLLLLBLLLLLfLiffffLLLALALA9997776PPDs4VG1J2cE2E222EE311cEW0101p12bJhP7'+
'MLACRKgPK6CQ9AMLLLLLoMB9786D5G0X332EEEc231GG4Dg7AAffiiflLMLBMLCLNLNLoLffffffffffLLLLLAABA99777PPD444J133W22EcE21112WI20103I2bVP99BMA88787CdAALLLMLoMBMBC876OH400113I3211004HDP78AAfLLLLLMCCMCCMN7K99BBLfLLLfLfffffffLfLLLLLM99977KZ444hFJ3cEW2311112W2I31p'+'1jE2V579MAA9B99BAALlLLLLLLMo99876DD4G031pI3J1FUa44KK6ABALoLLCCC7CCCC7m6666C9CCClMBLMLLLLLLLfffLLLLMLA9CQ87KOH54VF133331000IE2311Ij32cG47QAMMBBBALALALLALBLBMBC877D54G0000F0FGGGhZKK6d8BMoBMN7K6T666mTT5mD7PKDKPKP7K77CCCAMM9MNBLMLLMLAMABM877KsD4GFF01F00I'+'3W22I1X11322G47QMALBALoLLLALLoMBMMBC967g544GG0F0G4Gh5ZK6R889BA9976P544TtGteGGG4TG444444444444ZDmPPm777999B9MBMAM9Q8877DTHG0V00000I3E313p132WJG4R9AMAooLLALLABBLBLBM987KPDZ44G4G444sZD678989999K6P544G0GF1J13J0J3b1J1n0100JX1XV0GGG4GHZP667777R8CCACAR8KPDD'+'4GF0Fa01332220133233GZCCAAoMALALoALBLMMBM978K6PZ54454T4PDK67799999C7P5440J11b322223232Y23YE2bbbbb2b3b23X00UG45DmPP7677R9CCC8CR8KPTZ4G0aF012E130112Ec15PR99MABLBLBLMLBBMMA9977KODTZTDDDP6K6769NNBCC7g44013bbb0232c23J1F001013c1b13322bYEE23p0FG44TDPKD668C8'+
'C899C87KDZeG0GUF3W12I131223F4D7CAMLBMAMBBLMLBMABCCROPDPPPPKK7K78789NBCCKD4G03b121J0F0UFUGGUGtUGUGUhG40F133222W2IE200F0UhT4PDPKK6R78C9877KPD54GGUF1W23I0I32c2JhPKK8C9AMoMBBLBML9M9876KKP67K87R9798999C7KDT4X3323J0GGGG444THKHTDDTG4eGuG01JJ3323EW2EE10IJF0G'+'445DOD677878CCR6PPT4GGG021I3I21IW23aT4KK7999BMLBMLBMA9C887K6788C8M9999B9C77KDT0XI223F444PZD6KDP7RKDKKDTT4HTGGG0F013IcIEEEE2201000GGG4DPP6687787R7KDD5GG0F2E3I2I3IWc2G4HKR799BA9BAMLAM9777K688999MBMAMoMBCR7DT01123JFGDKT6P67687RK6K77KmZ4tGUG0UUF0II2EcEEE'+'EE221300F04445P6668777CKPPDT4G0IE3212I3IE2JG4H77R799ABAAML997R76799BAMALLLML997DTGG0b23FG4DKKK7799889C7787KPm5TUGU000J11I2EEEEEEEEE222131J0GG4s5P667K7CKKKDD44G03EcII3IEEc20UTDK6899BAALAMBC867689AALALLLMABB9DDG00332FUHPKK779999787778CPPPT4GU0022221IE2'+'2W2EEWEW21213F10J0VG445POSP7K7KKKD544UJ3I222IcEEW00UmPK789ABAMLBAC77RN8BAALLLLAoLB99DHT03W3FUTHPK7C7C878776KPKDD45e0033IE2W322232323313F010001J0JVUGGGh4TZPKKKK7KPPT4G03WEcIEEW2E20FTD6779A9LALACR67899ALALLfLLLBMB7DT0333JU4TDPK77877K67KDK4DT4F013222W33'+
'3333JJ0JJ0F0F0aFF0aF0J00F0JVGGGTDTPK6KKKZD54GG3322EE2EEc20G4PK789BAML9977689BALLLoLLLLLA97S4Fc3FFGT4HPK67KPKPDZ444G000232WFcFFF0FGGGG44444444eGUGGGGGG0GF000U0Ge4PmPPKPPKZDTGG13W1EW2WE221FTDP7Cd9ALAM967689BAALoLLfoLLA97SDGF23UTGHHZDPZ5DgDGJJn3133W3100'+'F40eG4D45ZOPKKODPPDTDDD5TH44GGGG00aFUGG45PDPKPKPPZ4GG12EcIEEEE23FGPK6CAAAALA96678BlALoLofLLLAL98S4F33c0UtGUGGHH4003013Y33cJV0GG4D5DgPKKP77KKOK6667KPP7PDKPDDT44GGG00FUGG444PP7OPPDT4413W2WWEEEW11GTD7R9BALAMB7KR99BBLALoLLLAAA97DT0F2W300000UF022222J3J4h5'+'ZTDPKZ7K7KR7R78R776887988C8CR76KKPgSDT444GUG00GG4DPgDP6OT4G022cIEEWE220FtPK69BBAL996g7999AALALAAAABM87DD40F3222222313c3JJJG4Z6KKK7RCR7R8R897989999999897C88C878777K7PKDZTG40GJ44G4DOD6ZPD44UF2EEEc2E2I2FGDK69ABAAB866699ALALBAALB99d97KS44GF133Wc3cVGhF4Z5'+'D6R7C8CR9Q87C8997989999989979989999798C8CR67PDDZ4GG0GGG44ZPZPPDD4G01EWEE3EEE3FUTP799AAL9866Rv9AMAoBMBB999896KDD4e00VJJnh445P577R9998MMA9A98999999999998979979vB9999999989977KPPPD44GV0V445DPKTP4HG012Ec21J313FU5P78ABLM986g79BAMAMBA99989877PKD5GV444hhPK5'+
'P77CMABMLMABMB999B9MB9999877977899v798N8N999999997767KDZ5GGG0GG44DmDZDTGU0EWE1F00100U4P7Q9AAM97OP7d9AMoM9978v78786PKPO4ZTODODPK78MLBLLMLfBL9B9B9A9A9C97777777R778778687688778789979R6R6PD5GhGVG4G4ZTZT4uG02EE20J00IJG4P789AAB87PO7CBMAMB978768687R87PK67KP'+'K77779MBfMLfLLLMoMB9A999897C77777R76R66KZPZmZ5ZP6K677C7C987786PZ4e40GGGG4D4DHTG00Ec2aUaF000TDR99dAM76OD7C9ALA978687R76877R7787C866AMMLLLLfLLLBAB9B999d99677P6K7RKKKKZ54VG3cJ33V0FG44KK77C887C7KPD4GJVUGGG4DT4TUG0EEW0GGUaFG4P688BA986PP78MLAM9676g76868989'+'9799A979MLLLLLLLLLoB9BCd998876KKK6KKDKg540Vnkk1J00J333F00G4HTS6R79R67KZ5e40G0U4GH4DTG00E22JGGe00G4K68ACAA7KPP69BMMB877Kg8786989B99AAMAMLLLLfLLLLLBMB99Q98877DODPPPgPPD0V3knV4G00U0133IE233FGTHP67R78K6KTG0GJ0FU444T4GUF22WFH4ZGGGZK6Q9d98RO5K68BL99CK6g777'+'877B9ABMALLLLLfLfLfLLLMBM998987KKZDZPDPKDD4VJJV44gHDutUU1313IW2WF0UhTOK6777RPP4400F00GG4ZTGGU22W05D7Gh4P6889A996OZP78MMBC867O787997AABLALALLLLLfLLLLLMBMB9C88KKZ5D5DDPKHZG13h4DgSrTGUUF0IIEE2231FUF45TZP7KK6KKZGG00000G4TTHGU32WFH7KT5D677C9d996ZPP7CAL987'+
'P7D7C8MNBLALALLLLfLfLLfLLoBLMNM987KD5545DDDD5GJnh4DKgSS4H003I2WE222331GG44D55PgK7KKZPT4F0000GG4TTGU12Y15K7DPmK68899B8OZPP7CAM977PK6R9CLBMLLAfLLfLffLfLofoLLCNM97PKe44454DPD4FJX5KRRKSD440JJ32323100G0G444445DPPKPKOKD4G011JX0e4T4GU12Y1Z7C7KPP78999966O5KK'+'7MA977P77CCAMLLLLLffLLffLfLLfoLBNBMC7PT44h445TPDDGkVPCR7KS4HG0J3kYcF0F0GHH44g4ZP5DPPKOPKDKD44FX1X000e4TGU1bEJD7CCCK67789987g55P78MA97PPKCRBMLLLLLLLffffLfLoLLLBBMCCKPTG40GGGDDKT0nh69BCKSH0032YcVVG44SRRKRKRR97P66KODP6gPKZT401111J04G4GUFIw1Z9AC7K687987C'+'6PO5KP9MBCKPP8CBALLALLLLfLffLLLfLLoBMBCK6teU000GG4DKtFGV68NBCPHUUI223FVegKRCSgRK7K7CQ987KP66gOPPD441JJ31XXU4e4G3IwXD9o98687C89CCRO5DP7CACCDKO79MLLLfLLLffffLfffLLLLM996TeGG0J00G4DTDFJqK89996T402E23FG4SSSG0G0F0F0F4P7RRC666gPOD5G00J113X00eG4U0EEXDBMoC7C'+'989CdR6OTOKP9M97PKZ8MoBfLLfLfLffLiLfLfoL997O4e0J0JJ0G45KH4F0OR8967mGJ3223FTHRtJ2312YEY2c33VUD7RQ8KOPP5DGG01b13330G4eG1EEXKBLM99989C8CR6OTZK699C7KO6CABLLLLLLffLLLLfLLBCC7K5GJ1J3n3nV4ZKSZFGOR7CR6O4Jkb2cGuSH11b12b3123233323VGRR87KPODT4002222310GGGU0Iw0P'+
'MLBM99999C86KZmOP7CQ7POD6CAMBLLLLLLLoLLioLLBC66TGn1Jb13cG4DDKT4JZKC8CRZG03kWFGHtUF2221JX3E32222WEW33GgRR66DPT4002EW32J0V4GG1EwGKALBA9B999877ZPP5KR897ZPP8CALLBLoLLALoLooBBCC6Te0J1Xb32c0hTDKP4JsPR797K40X23J4GG02E3000IEE33I222EE2W23GgC7KPm44022EEE3JJ4GG'+'00E2h7MLMo9B99977PDP5P6R977ZP67A9AMBBLBBoBBBMMCC66tF1322EEE3JG45K7gGnOR78774403wJVGHG023JIEE2100p011IEEEEW2nGgKCDP4G11EEEW3FX0G0U3Wc5MLMABMB99977P5P5KK6CRK4O5R89AMBMB9M97CAC7Cmt5J3E2EWEww1V4TK7SGkh6KR97K4022334S1JJ10EW1FUF00I22222EE2Eb315KKDm441bEEEW'+'001G0002cJPAMLABL9B9C7KZP5ZOKRR6ZhsD78CC897C79RPRKPPK5cF22WIEEEE2JGTKKKDnVZ7R777DG322bHH0G30132aUa1133W333W2EEEWEbc4DPPD4G1bEEEE31J0G002cJ6lAMABMBC9R6Ks5PPK6R8KZh5P67R7K7KP68K4ZPD4GJ3223IEEEww344P7RKTnq7g687KT1wb2ju0FJJJ13FUaJcnVFeGeUF0EcEE2c2VTPDT40'+'12EEEE3c0VU00EcF7LlBBMo9977Kg5PPPZR8KH4hT6KRPDZD4ODKH4GG4033J1312IE2wX0GZKCRPGnZKKPCRT0322Xt02JJ0200GGJ3JsTDPgHTGF0I32223V4TDHG0b2EEWI30J000IWcmAlB8BBM97CROPZ5PKP6RZGGhT7KKDT440GG5032323c1VUF222IwEXG4P7CRT3GDD78CK0c2Y1Gu333G2J1UGJnV5P7ROKPDG4F00I3c3F'+
'GHH4G122WEEE3JJG00IWF7ML897999786KZTODOK7g4G0hTDPHT00j331JE2Y23J0GF002132W30457Q97Gb4DZCC7T03YW0GUJ1c13XUU3JhPCR8876ROH4GUa3F01FG44G032WIEEE3JVUU3IWmMMA79798787gDPZDPD7KDG00hTDTG01jEb2bYE00aFtGGF01J1323F4ZPCACSJn4DKR7KG02c2FT1J1XE00U3cGPRQ98888KZ54GG'+'F001JFU4G003I2EEEI3JF0UIEVRMBB7879777KDODDPOD7K411JGGeGJ3E2233I3FutGUtGFUF0133EF04P6AMR5340ZR7KKGIY2FtG02J230t03hPR8AQ99866Z5ZG4UJ1F0FGGU413EW2EEE31F00W2hMMM9687787KZPZPZPKDZT433J0F0333Y33U0a0ZPDDT44UF0012Ec04Z79MMRe3V5PCRPT02WJFu311kX0U01cO79CAACd87'+'O554GGGFF0UGUG00p222W2EI2F0F13VCMM76P67R6KOPP6Z6DTDD4J2233223c40G44KTPOPKZT4GG010323004O8MMMKF1Gs77CDT11c3GU1j03J4001V79AACQ9797DP54GG40F0FUG000132222IE1p02ckx8MC7KOKKP7KPPOP6ODPSHU3EEEIEc3G444OK666PKPZT4GUF01321FGZ69MLQS2VGZKK7SG1bc3t0pI33JH0X1OClA9'+'988987PP544400000a0U013122EEE2000Wch6MA7KZDP7KPPP6OPPDPSHG0W0IEW31q4Og6R8777KKOH44U0001E2Fu4K69LlCG3VGP77KT0322FGp1b3cVHUbGKAABC8879C7PP55GG0GF00J0J111I2222301123hmQ9CgDPPZKPPPPOPPPDDSG023I33FF4ZPK7R98C87KPD44GGF002WF0HD68ALlCF3J4K7RKG01E2G00I32VTUJ3'+
'479M9977R8CR6O4440G000aJ0Jp13I2WI31aI3ccPMMR7D55PmPKPPPPKPDPDT0W1a3FJ04OK78CACA8C7PDZ44G000123FG4g7AMfMK03V4PR7SG0EW3G3UE31G4GX15R9L97R668877D55G0G0JJJ11113IE230I333c35RMR7D555DPKTPP6PPPDDTU310Uc04OKCQB9BM9C877DZ4GGUF002c3GGDK6LLlMT3c046R7DG3IEcG30I3'+'14441nK7MA976g66C87KD5GG0F0J01133I3313I13ccJZ7CQPT5T45DTDPPPKPDDTDG03JaGG57R9MLALBMA977K4T4GG00a2cWGhDP79AfLMF31446R7443Eb2G31jIJ444306CMA77KOD6R7RPPD4GJ00J10I131301113JcXORQRKm445e4DDmPTPKDDD4DGWcaGFD7CALLALLoB997KOHG0G0U023EchTP7CALLlC433VD6R6H033I'+'14EpIw045G2hKMM97KODPPOK7R7Z440F0001J11111X2233h6QQCPT4he44T4D7DPPPDDDT0JGGTDDCAAlLLffoBM97PPDG400F012c3FeZK7CAfLMCF23G4R7740pIE14E13E054GYGKCM87KDODPZ67R7KD44UFF03F1n3J111JJ56RCRPT4eGh444TD5DPKDT4H413V4eZC8MLLLfLoBBN96PD5U0F00112WFU5T6CdBffMTcb34D68'+'KT03Iw0H21b2VDT0YFKQ977PDPDODZP7R7SK4TG0GF0Jn0nV0V4gRCQ7D44hGGheGT4DDPPKTHH4G3V5m56MALffffLLBM96P554G001113I2V4m689BLLfQ53W0GgR7P40I2E0421b2GDDGWGKCQ7PPPPDZ5DPPKKRKPKHT444GGh4TgSRQRRPH4eGGGGGG44DDPPDDDD403V5P679LLfffffLLB96P544G00I22222c04K7CdBffl9ac'+
'31GKR7m4032EJ41XI2GDDe30PQ97KmDKZDm55P5KPR7KKPSKDKKKKRRRRRDT44hGGGGGG45DDPPPDT4HG3ceK67ALLifffLLo997Z54eUG023EEE320G57C9BALLLCh3234D86P503Iw0400E2G5SH2VTCMCPTZPDPDP55s5PKKKK7RCR7RRCR7RPT44hhGGGGGG44DDODPDTDDGn3hZ69BLfiifffLL996KZ44U0F23EEE331G4KRCBAB'+'fLL7FW114g77P40132J4U1E2VTS41n5CQ7PTDDPSPDO5554ZPPKPKKK6K6KKZm4hh4eGGGGGG44DTZDPZTDT40VGP78BLfiiiffLLB886Z44GF012E3E331aGDC78BMLLLLKJ23XUK87T5013EJTG0E3FHKg33G7Q7K5DDDDPPPDPs54h54sZ5554Zs4s4se4G44GGG44HTDZDO4T5T403VP7RALfiiiifLBB887ZZ4U0022EEE3JFUh5K'+'7CAMBMfLM51221468Km4003EG4GFbE0HgHGY3SRCK44HDKKP66P5ZZT4se45e44h4545T444HH444D5DP5TPD44SGJ3VP68ALfiiiifLLM996PD4G0022EEWEJaFGeP7R9AM9LBL9e3EwJ4677D5a1IwJ44FX20GKKG12GRC7H4H4gD666ODPDZT4Z454545H5T4HD4r444ZZ5D55TZT4DTtJnhP69ALfiiiifLMM9967D54UF12EEIE3a'+'0G4ZK7A9MABMfLKG2W21hP77PT013214511b0GSKDnb06CRD444DKP66KPKOSDPPDmDDZDmD4gDHZD54ZD5T4ZT44G4HD0cGP79AfffiiifLMB97yPPT4G0122WE231aG4P678AMAMBLLMKF1w23hK7PPG00pI3eHJ0114DKD43nD8CD444OD6K666KPKPKPPKDPDPDPgTHDP5TZD544444H44H40FV5CAMfffiilflB99yK6P55GG012W'+
'IW1J0e4PK68BMBABBMLBPG2EW0GP77S5UU3230T0003VD7K40c47RKTse4DPKK6767KP6KPPPPPgDDDZ5TP5555TGGHG0GHrUJchP7AMLffiffLLA9967POT44G0132222JGG4D6789MAAABMLA95JbEW0GD7KDTG0132FTG1V1G4RKDh3GDR77DhG45DKPKKK666KPPKZPPDZ554Z5555eGGGHHuHUJ3khO79lfffiiflLM78yKP5T444'+'0013W2E1GVZD6789BLLABBAL975JbEW0FTgKT4G0012F0T10V0sK7KT0n4PR7KhFhG4rSPKyK66KP6ODPZP54545P555TGHHHHH0Jbkh6ClALfifLilL9776PPT544G00J1b2W0345Z6779ALALAo9BMB74122E2J4KPK4G00230UK3VGJ4PKKK4kX4PRK5e00GHHK6K6666KODPDPZ544s45T5eGHHHHU03kn57CALffffLLLLC77PPD5'+'44GG400X1b222asPP67AAABLLBBB9A9K41W2EWF4DKDTG0F12c0HT0GcVPKC7DXbJ5K6DG01jUHDPK6K66KKKDKZD5ZDZD5TTTHHHu41kYFP7QAMLLfLfLoCNN6PDD4eGG0U00003223005P7789ALALAo99BM8KG3WIEW0GDDPH4G0022FtDGcGGGDR7KGXns47Sg0X3304TKmPR6RPKOKKKDKDKDTDSSHTUV2knh7CCAMLLLLLLoBCN6'+'mD54TGUGF00J013IW0JtO6789ALALAo9NBA97T02WEEE3FHDD5GG0F222tT4cV4JZ7KRKG33G4KSu03I10GG5DODDDPSgDDgDKDDDDD4GJ33kV57CAMLLALLALBCNNmPTZ4GUGF00J0p1pIE21UTP789AALALo9NB999KHJ2WIEW304DT44G0F122UT443n4ZSR7R4VnnVHSrSU3b33cGG4HKgS4SKDgSDDD4GG13nVnPP7CCAMLLLLBMB'+
'99665D5TUGa0011p11pIwW3FGu6699ALBLB9N999987412EEE22J44DZ4GG0332FtZTnn4H47CR8ZG3n4HrSHG1YE33cJ0GGG4H44GG40J0JnnV45P68CAMMALMBMB9776OTZTGGGU01II22IIEE2330GT679AAAMBB99N9897SG12WEE3E3VT4D4GGFp3IpG4T403VHPCCQ6ZV1kXGHKSG13c3J3kwbJ0n33c333kcVG45K67R99AMLMo'+'MB9977KZDDH4GUUJ1132E2IWEwb3JG4T6899BMAB9B9989C7HG12W22IW3F44H4GG001I30e4D0304O7798PHV13c4TPDG0I2J0400JJ0JJ0VGGGh4PK68C7AABMBMA999777DKZD44GUF013IEcEE22233JF4GH679A9ABA9Bd9A9R74012WIE13214G4G4GJ03Ib0G444H1qTZ79CRK4VnncVeHStUF3b0UTHHH44ZTHKD7R7R89M9MM'+'M9A98977KK6PZDH4GU000IEcEWI11F000F0G4D799BABA9BABACC7SGU32EW100210G4G0F0003I1404DDG3GD777R8K44nkb3GUttGUF23FGHSgKKKR7RCR8M9Q9A999C8C8877K6PDT44GUUF1IEWE11FF00FUF44ZPK99BABLBABA9CQR6gU02E323I133JG0G0UGFp1b104F4D5J3G4RRCRKK4s3n23F0tUTUGUF31nG4KKKR7R8CQ'+'89CCQ9887R6KKPPDP5H4GG0FpIEE33FF0UhT455TOD7KBAAALALAAo9C86K4G012331F00330UG0aG0113304GG5ZHG3hPD6Q8RO44VJ3210UGtTGUJ3k3V4GG45KKKOgK7K6KKKKPKPKZDTZTG400011EW21F0GG4DDPP6P7R7QALLfLfLLALC87g5HG0133310002c0F0UFG0033I144GVTSHG3VP6R6RRKZZG3n33JJ00UGG400J3kk'+
'nJVV40Gh4Z5ZTZDPZHZT444GG0G1322223FU44DDK677R899AMffiLffLLL997KZ4e0001c100Ja2E3a00F0001122GGVGGGHDVVVPK7RR6KPD4VJ3333100UG0G0GJJn3J3k3cJ0GGGGG4GGGGG4UG00F1123W31FUe4DP67R7CA9AMLLfiiiffLLB987D5GG0UFGF1J0UF0E31210000Jp2WVG4G0G4HP4cc5KR6R67gT4e0c3333301'+'00000G0J0bW332Y3c13JX00U00FUF00022c23JFUe4gP77R99AMALffLiiiiffLBBCKPZ5GGGGGG0J0FUUF2E3021F01p1233TS4J444DKeGnVP87RKKDP44FG3cEW331101000U03I313Ec2W332010001001122W33FFU4ZDP6R89AALLfLfffiiiifLLLC7PZD4444e4GGVUG0a00E232101pJp213Fu44GG40tDP4cVZKKRKPPZeG0'+'G132E222I00JJUa0J0J0F0I332EE2E3I2I2122c23F0GGDZP6879ALLLffifiiiiiffLL977DOT4G4D545G4F0FUUJ2W21220Jp1032FGHHG4GG4THD4GYG5KKKDDT4G00F022E23II00J0UUUUJ0JUa31EcEWEcEcW2Ec23FG4G4KK789BALoLffifiiiiifiLLM97PDT444HPDTD54G00GUF2EW2EcI11131IE1HHT4hGGG4HD4VnVZ4'+'KDKHTGGU0111IEW3I0JUJ0JUttttFFJ0001J3c2313c01GG4G4KK6899ALoLLfLiiiiiiiffLLM96P5D44ZDPDPPT44G0GUF3IEWEE2203132E2GHS4T4t444HZ4gGk3VHTHHSuG013IEYI23JFUUtGtheGGGGGGGaF0aFaFFFUGG444DPK6889BMLLLfiLiLiLiffiLLBM7KOT44ZTDPPPPD54GJG0U12YIEEEW120I1W20TSDTT4gH4D'+
'44444VFb1VGUG001p3EEW3JJJGFGheT4D5D5D5H444TT4Tu4TG44ZDPKK789BMALLLfLiiififffLLBM9CPDZ4Z4DPKPPPP4e040G00EEWIWEW212112E20TKT4HDZDDrZP4V440c33JJ133Iw2w1V0F4h555PPP66P6P7P7KKPKPKDPHDZDDPgP6899ALLLLLfiLiLiLiLLLLLMCRPD544ZDPKP6KZT4G0G0002W1IE22Ec23222WJ4Km'+'DTODDPKPKZD40JJG3J13b3IbX0G445ZP77878777998C8C8877KPKPDPDPOgP77R9BMBLBfLfLifffLfLoLBM97KD5444sDKK6KKD54VGJ0F022222I3EW2I222W3emKKD5DODgP66gDDDGWF13321000Gr4KP77899AMALALAAMBA897C766PPPPDPKP67799BMLLBLLLLLLLLLBMB99R6gT4GV44ZKg6KKZ4e00100013E2102EEWcII'+'EW2JTSPPP5POPPR7RKKSTDGGG3W3221Hr4gKCQAMLLALLMLALAA9A997777KPODPPOKP77899BMALLBLLLoLBL89787KDT40X00G5PPKKZH4UFX111J13c2101132EEW22EEFSSK5PmP5PPKKK7K7KPP54J3bYEb004P7R9AAMlAMLA9AMBM9978787KKODKPKP7KK789C99B9Mo9NMNNB66KPDZ4UFjI3F0G5DPDZT0003331X2323J00'+'002W22WIWE1tT7T5P5PPPOgKK77776Ks441X211VG4Z668C89A999999C89787877KgP6PKOKSK66878C89A99999977PZZ54hF03IE22JGG5DD44G002I21323Ec01FJ0023EE3EEc0tKDDm55DTDDKKK77R76Kg4gG00V0V5POK67777877777687777R6R66666KKP6K66R78787C89797766ZZ5GGJ1b2EEW23F05DZTH00I2E3223'+
'W311F0UUF013WEcEE2aHKTDeZ45T4ZPK6R788R6RgSH44V4TKK6787R767766666666R66868R766766767gN68787897C776OZT4G0J32EE2IE2F445H4GG13W3E22W221F0UGGUF013EEEWIctDSZ4544444DPK68788CRR8KD4he4g668C898996766ggO6Kg66R77788877R7877876877C8C877KPHDG40J12WIEEE20G45Z4G01b'+'2EEEcE2E30JGGt4eG033EEEE3FGSH5T4GGG44ZP76889C98CCRP54s5PR7A99999787666Pg6P666878C989797N8776877R77R7RK66DH44G022EEEEE10GZD5H4UJ32EW2EEEW30UGGTHH4eUJ3EWEE20HD4440V00G4DZK68989AM997KZ55Z77CAMAC998876KODKOKK67R7999B9B99777R766K6KK7KK7KDHHTUF32EIEwbFU45D'+'ZT4G12W2EEWEW121FUGT4PHTG01cEW2W14H4HG00J0GG44OP78C99B9BCCKs5DP68MAM9A8977KgPZPDOK67789B9ABA9978766KPKZPSDKDSKTHDtG00IEEW21G45DPPZ4GX2E2EEIEE223aFGGHDTDTGU0I2Eb2J44GG0J01XJ0G4ZP7799BMMBA8KDsP67CAMA9AC8877KODKP66R999BAMLBMB8CK6PDZ54THD5HDTGTt4Ga1J3231'+'045KP6ZD4G02WI2EEEWEcI0a0GT4DTH4G002W2314G4400X110J045ZP789BBMBM87P5P67CA9AMBAC87KKgP6K66899BBMLAMABCCKD554G0G0G0GG40GGGaGF011F0FTP67PKOHT01E32E2EEW2100aGG44D4TUG01323n0444UF031331V445P799BBMAM96POP7CAMABA99C8R7P7KK687999ALBMLA9RKDTh0JJ333333JJ1JF0aF'+
'U1F10F4D6676KKD4G12E2E2EW2213JaFGGG44H4GUF001JG4G4G00333333004mKy7BMoML986ZP7R9AA9ABAC977R76R7789BBMAMLA9CKDT4F32k2W3WcW1323cF0F0F00G4Z6777R6KP4GXEEc2222EEcI000UG04GHG440U00GG4TGUF131IIE22F04mK779BMAM9OTP789MLAo9B998C77R7789B9AMMAMAC7HDG032W323312333'+'2c2111000U4DP77C8876KD4F2W2IEcEEW23121F000444G4GG0GG45TGG031I3E2WI2FU5P779AMLB86PD67AAABMAB999C7R78N999A9AL9ACKKGG0c2320100011322W233J100GTD7R99987ROD4U12E12IEEEEc23I1X1000G4he404h4TeG002213IEEEI2FGZP89MALMB6POP7CAMoBAoB999C87v8999B9B9CR6P440J2W23010'+'10J011323331F0U4HKR7A999877S4G0EcI2E1WEcI223331XJXV4e40444TT44a1321IEEEEEE1G4K689MLL97OTP7CABALBBMNM99798vN9B99997KO450J13W2I01pUUUJ0J#';
 ttUser='T1V00L00))))0000~'+'000000000000000000000000000000000000mCFUUWPpcD0pECR0cvvt0C3tW1OtiP3WDFU60000000000000000000000000000000000000#';
 ttShade1='T1300300))))0000~'+'GG#';
 ttShade2='T1300300))))0000~'+'OO#';
 ttShade3='T1300300))))0000~'+'OQ#';
 ttShade4='T1300300))))0000~'+'uw#';
 ttShade5='T1300300))))0000~'+'ww#';
 ttShade6='T1300300))))0000~'+'yw#';
 ttShade7='T1300300))))0000~'+'yx#';
 ttShade8='T13003000000))))~'+'20#';
 //Shapes
 ttDot='T2500500))))0000))l)~'+'KPLLLL5LM#';
 ttDiamond='T1700700))))0000~'+'8uuxlFE88#';
 ttTriangle='T1700700))))0000~'+'8umndl)))#';
 ttDot2='T2900900))))0000))l)~'+'GL1KLbLLLLLLLLLLLLLLLKLbGL1#';
 ttTriangle2='T1B00B00))))0000~'+'W0u0S0VWFuFy7)d)x))))#';
 //Textures
 ttOvals='T1C00C000000))))~'+'0pCCp0p0CC0p0pCCp0p0CC0p#';
 ttTiles='T1C00C000000))))~'+'aaAAHHAAaaHHaaAAHHAAaaHH#';
 ttBricks='T1C00C00))))0000~'+'((TThhttxxzz((TThhttxxzz#';
 ttBricks2='T1C00C00))))0000~'+'((TzhxttxhzT((TVhlttlhVT#';
 ttBricks3='T1C00C00))))0000~'+'((TzhxttxhzT((TzhxttxhzT#';
 ttDiamonds='T1C00C00))))0000~'+'aakk))kkaa))aarr))rraa))#';

{Large Textures B/W}
 ttBrick='T1a10a100000))))~'+'0000000000000000W))))))))))))))))RLMbLPLMbhQLMbLfgMbLPLMbgQLMbLPLMbgQhsgjQLsghQhsgjgjMbhvQkjRPjMbhPLMbg9LMfhGfkbg9LggQPDkbgJrjBDPDkbjPfsicQ5i2bvikicQrgbx8BcALtsycr8NM9000000G000100000u)(l))))))t))l)x)UdrhjiRwb)zF)hw(dCx2sAZgnAIIsaMX0xCIlJLNfJUhRqcjvF'+'sbROhigEBLfQLfLYiYgvkDN5jrgMngcgtONofLbjNrSbhTbtQrQcZnQ94iIhJLsQLgcwe600600cDjbgibj200e))))78CdQ5100(l)t)nkw)B002G)(lMxhCWiKkl)lY))lRhQ6BzFrA9m)()VhORMfFraqQrzDgNMHrMfhPkysSji4l8jhjYhfMkKJLgKtcqkI5RfgsgjZ100mgwcLjLhMbIP50)))WLMoAhCbRRh2u)RU(7gTjrLlPD'+'0W)dBZfaFeKbao40W)xhSRfjP)moEN5W)x(MLM9sKkkXSI1u))QehorbwgLw314mlMevvQPbPHvQ(N0zVbxfJsQA00KMhpztFhQbcgJ1m))WAPJhiqjscsQ3y)y)ZjMpMxighQL2SN53AdbhKIHNPLM0(pgI)o6PBxipQkg0xhSLEHUdMnIhif0u)MLRhjZjcrMpLN0)UhhIBvAzKfbhao0(lLPrKD3DtEZPbt4lhegk5300uQoZkQ1)Pr'+
  'MbL3u)VgCsZK2srkggv5(Fhpnah5W(jYLPh6eNvA(nSD))BLxkEbuRDMbr5LnTEHBMg4u7scgywugMrskkj1uEdISDJXJbhSchO0(lTPRRPhShSBxOL2lMf8hH9kbh5BvoMW)RjsrriroOpwkMZWRbgagi10SBlHgah8VgcrPL1uFOvqnjP0(crgYk2((x8sw20W)LgLMd2yhb(qLX)p)jQggQ9Slicwigi)U5NbLP1wtKlOLLDFahrQfj'+'2yNqoKhQQvyObS92W)RBLzojUCQPg6hXyxTApAHTbTmfnrI1z)6XTLpBPfTihic0)MXkP9NLp9c(1570)ZghMgLBLrbNn70m)hPbMgjCG0ZQg()))CLgcQf91yJKQbZkjYRbsQj6GV)zWjQNuiIrOLgaW)rA)XQExsQkQsA0uVhKLz3bDZNfLX0u)(IBhSbFOTQgp0u)(lIDrTfwUWKU1W)(h0OBlqqLQ)700i)bWvVQJKJPhLI)))tLvd'+'MgIyclQpsS)yNiQIcQPRLCg9LIB83ALfRRLkHTUvDTp(rVrgPbgcajW0IrPjaCfSNgcMf00eA08JsMlLNbj200m)()V0gLbgH000(l))bxy)F0080u)(lRxAgQ95v)))())lRRRMhrirkaEzlldIORAfDfILPMNo2P6PxMfjPkMpjELRTlSNMXrfLgaQjaiCRMABcgfbAbjPBrwLUgQLzOjgcjQLMrQckQvgiqkaLhMkgb809OjMTtYswA'+'000000G000100800W)x)()))))t)z)(l)xssh)PLhs)z)(lsw(QZZ9esoL4KJa8QRQe99N(bIfQ)YRvTAbvfTQbaPRMZfgQYYTfbMffwckfMPLMfNhKscgvLMdoPLkgjPBwgfQLccAPJggQfKAbJfLgbsORgcQPRsbjPRgg#';
 ttGranite='T10400400000))))~'+'CA(TTcrlgMr)234JguCYI4cN82QDSn)twwqKfB49AuUF)kAByav9OtOPAuxz5zHDJYdDz)RxXjCDhdHrTQcOgrRC1PRixYmk7gFBNysIiWOJk9RJ3Idqt7xMKMeycz3WXiKzkVyQ5QwYmJcoXj17THLyJSv)SFU4A1cgr(p1sFCfCRfJQwUv0nH5HMpIj7tuIMCuKz52DYh5iqMbP)jb5RrUhCHjYzOlqQ9kKshem1aO1n(rHOpVGIuF6K'+'erJDbeekbYetsCtxpjD2O1EOqJBdSwUYXmlhI1(QpiZqm0h88KxtmwQwmjiForN)slz1jar8AK9Hgx6HkxNzKNoHtsqBc9mfmt(5jY6ILamOt8yO27Cfsc4nYqxfTd0SrbiZl2Se0eFU3Y7rdqEfhTmq4Y185Bloec)iZFkNT(xpgEcJ719(R5cz3rIaApNXNjPmd(S8f0KywpPNfLHKS2nkG6Zlh)jHUHXBEcvWKP9AnrXCUnt225uOL)'+'lqpnez1SrheuI16og2hTrXyIDyHYxfNYt1tt0DUYTg84YBW6F0jl3WzXfmVUpou3I6ebdK1nNExEIItAheTporyEr1TrIwYS4XzwtfnsIZSJnwcXkMCVTNEHX1Sy8EGfTBqeE7CF3HjMWum6drRryuBRQlARAvPvrfj(zI94is8cTBbNW20tM1yYso4kouYXH7CbpDOxSUPsFP8eiqqT7nNVy0YoycIR45VG)AyxhqsoJKArC0AkzuagJ6'+
'TQlau0e(mJwYFFgmj1lWwoUTcIiOd7tSnzTkIS)KiBVphqs))bk)pH3sRkEDx5u4QZ4lyqAfERvjRpSQiUOoqjxbeQ1w1FwX(XlBeldxkf454mXS(yvsc4r8Zd28AwkFQN96rGuOqf7XIi6rlQRWfaFQJeNh(YdYdjXC7rDk)jeFls5eWsJlpVGD3JvkXbIzHlNZN6scAanoCEsO0(YLfdFbiQeGHtcXgGqnJUCG9UJoOiopyxRbO8fDs9'+'7Mlcql8(4anCM(Dl19vGOUU32cR8GZwY69H6bU7bg8gTYYEqHmuR5n3gO7BcXZcmRYz1Tkfh2zCRv4h0qSFhlhqQ)4xxihx3nSU8hISfCbevD7c8rBgaMT0uVMJ(C5Vi(Qe4vLZezYD0N6j9osHgXuVnBHK9MSaNItTtuJAkvuyFVZNImOrttek)cAmtGc(slBdUX8CpMEIzoxv0gLnRq40XRcXlom6uPbn30iFbz8O39IFuIAAlebCKIZ'+'yOxTREqXVt0oCMzCl8fY7GBoKX1fInneU7YkNsW9NpPgOFtlk7goYuHVI02H1Yynaars1uK1rl(j36f9IxtqoNt4iZx0nrRlGOXPmeTc5CdtU3KyqDnJPfIn7YvhzE83vVE6rkMsZi4xZukyU1M3ftXgcXT)cQNW2VtFBZyTkNAti9JXm2QCXVa9TBmfeybsVQK(hH7Q(eHimRfL9b)LFFVf5AyTb9oYc1u0a(uMsq)8eEiWhtiGXT)h3p'+'23mdjj41kOl8ZzxhNwV7(0oPSikaFEJDVA35hcMrvkcLUNbLJ3en5PNKo6FfW4IY3USN5pAcWWtlO66uBBt)pFuAg7ttQByCd2queHzTm9EikuR(ivKr3bPx5GuVH(YtRFctWVqoFOkNoxVglrFZle6NcCVIeAsA7hgfbDvks6FcUVBuyqgXuM)ZWQm7mEnYFFsA4Q8XiOQxZsGGHUpIUa66tf2rKBXYRBCcHRbEstkzrsMPqiOrZmSqXD'+
'5zVwlUpgL8Oa)H6luRATq)x(8UD4pN3ii0hGLoipcxC5TV)ax1ShBEVzfhxAOM1zjsIvZaKcf8IQFK9J)lBRlQCGm2fD9Q8NrwKT63YTJOMUN6zKXwiUGbukI4xXIYJtAhdWnvW2WMwsv7thrlYh73)aDIMbFkfod8oPbtGg9k9M1VNQiVkFYaXL99fzrMhE6n(Y57H8WAPqOrPY3D08Fb3KK)iUJkk8H(kB0)yAY4XnqfD2xyDyszG17K'+'UYJv8n6sLR1px5flP4HvrQGHxnxweprvRe13q)KChCtV3kThJn22WFJX7VsIsCYnWHoAw4a5MddOeoNiOQ9PgULya)GrxGhSKPylU3yNfgISeRvnV6yPYJYsrV2bUwaPoJmGa65Q3wimj(rppFdzjbsUJIlBJblfj49IBax)I6L)VVUT4VanDjKo9kpEAWD8nMGnTBtnTZ4En0ZFAYY2m56fZRUgwpt8r)f6sjB2YItpyy(I04qFIBh6j2'+'Snqoa6MohRcPT723UcC8Jrd(CzGMvTpeGpEnUmgFolSjXu6pmMaLvDI4OtGZthi90108k69cOxwezFi6JINw5FXAsHsQpLsY6IEfveTz5YHz0X8tRQv3hLDj8vihnAC)RDfg1rUMtMMiA4wOG(4fCbWbUL31EHnIG(N433ujEP43weSPZFjazxoxNHG57562rjKVkJEs0MpAClFQXctKJksBFhqCmmpyTtHb08XW1QzwSGuXFs)8obBYau'+'aIygqDh(Td02HzVSao81zA4ZZecUN4tBy(4al5XlwLNdwiLLg8Ei6r(0rL3d)hhbweQ0WO6ZVtjMoflX7F)fE2drrqiY(MtpsZOE4jNeyrcFnEV93UJ67LLwoapN(HnXjhjZr1gCR2EWlX(G3j(JSLGtFXKmS)NAZ9wr8qE2w)dw1DGAMZItnSxU9ZhJnXN6A)zmZYSMf)7AXTnzA7xjEkFkzlbo(C6EoIO6IbCsQ2zt(9gZCHGgxBsMCZ'+
'9KL56Bd0KK1K3iZj8VvQ8BGdGkk5KsOk)haRu3Pde3UIOK(4GGMInJxkLxotuNOGowEFa7J6YoN)kJ80hOJkBGbFtMfP9NeEpyNFKyByR6mKUACNWgLvEFg2eJsbOYhMhT0lc6W7i6jIT(Ka0LlMfa5qz43CszYSPZ2ouKvfoPBlaXQTb8lDsOnqapRh(f(ohKAGVkRnVmfenpIHF6OWTngcl1yGjHwpmcUcycrb6SDDqN0phj0UmMIzm0'+'Gx)MEhF9KDkF2EX9yICd2PYkIikGfq3o(HRILnVhkUFeoblaKbxquhJpFJ8fjvpQac)7(3KwxeAeemk9PCp8cpsFtRQrSRR5XLRtQcBWb(Brl8Kjdwu1w0p1t1ooTpDNmXYNjy4M9PaM5SMJTQ417xdFcpf3h5xOJ1I1LCK)wHrKsAV4SWoM5W)uvmcvilpwmdSs5sjLTGtTYtaTKF3zHqKVFo1AqjtVxPUBUccvjk7iIVvBdLqoHN1lfP'+'j7hfEH5x8)u4WA7T3tRlnznteUW2es89vk9Ch2a)pHPOLX8P3x7DIysQk8kRE)0fi3(JIFFvJVM6YA16IixY6)9a7BJo(EzSvg5l0wNXSxwPUBmXBGqfv(yZzuzAyUiOYDyXYUAZi9lQ0DBdCEjzSjCCfUqR2ukyguQ(J)B3XhNStOgFqa(YtlbNOoY)ls4BI3CmN(jcArE0dF(1H4ieaOy4qWIh9zpbFraWIeWuXxgC0oYs(BD8WPlRei'+'Msfagne3bqkgiyZhIAkmP1TqqEA(GgFISy7fuz)OqCsDjW5rMaL)TLsZSj14GZE3YcM0I1s7ncp6KvZc1xlw4a5iwSIr2tod6khKWRZpKcKYZmZHX)GYb8JuTzBDKsdMJZDDYa4LKHfMLMFfDj5knhiPCP6aFOcJJZ7zSsKlsDIND2)TnIMGbZn6la6VuuIV7Dz8QjR8C2xS)J)kxdG0GMmzzsf9k6sw6ZwJMg5r(PGPigCrgePDcIni59'+
'kgrMfwRwxRkQ1epPRgWgcnwlkjS2VPchSakIixpNW1Kvh(Q7evUOchvs5mHeBRvlH1CryQj4c(R43b)moiO93iPF6eC7tslFFju2WGMx5qokudQ3iPRY0W8OLZUptzXmGpXxuEuNBAx6zUV6NHEHDlj(o0qY6Haaj6OeFqZQejjJ7RxbazzNb1)J1yFBT)scqCyEyXlEa3FlnHsTHLSQfRwMMpAj8Zooli1pSKvFLRtg8sj)mqDIUjTTlX'+'PAkH7lUkYGnejeYBX3cs)TQ75)ThzvngXWOoEfGwXDfqJjrMc9QcwT1ljOYUoWtgm7PywQTHeepkIulNSA4deL0ujDcw06BtdazlBK1bsocvp3RTjGx3p9qtDPi21xAWgKvk6EschJ8UQt7piKLtPrIP(8TloEySmbcVtVu2xbGzPcCh6SRThGZVUWFZjsGotWSIgaX79iZ2t3JHrqkHYJT)ESaWmwF)sR93CTGD2GkM5WhBSiDBqULUpl'+'CsbYO)vha0S)VW3)u1RD7)NndowkV)NqD7f8Y9gwvOVZgKtmkVB26pUskh2pbcvc)P4lFBUV01exo65P8YYkXU1PfwRG6fPmbZZZsx4(VCqEMtaUTbg6nK)N0WOcnNPTTWV)JmjPJ6vzpjlFaKBmkTuje6mCA8iEF8S)lkMRSdvZBQgfyOToZ6vhS7M0BXSjySffYRXLUnfRlNDw7qlSdWF)zMrEU6xecze)xDm(48fwLblkTV2NHc95Cd'+'MAa63r5clhyEivaTpY95fiSfJUCs0sikUZ9o9xsGFP4FYW7ZJsn65ZFrFS6hmZmhugwLFBiwXVyujKrwqNlDrRYs2Rj8ki)mwI9Gz3(F9MpHXr2BviL)1Lj36fNpGcocB9SaZSoDl3mbAQoGORE13g4)fhRss(dhkdHTN5O8xwtilGCrRh63z021CjPtew1bHA222xV7U7FZZiCjP4aCCajZA)072nwPIf)yZ2OlNEp5yM81laz5M4PTIn'+
'MxYvto5AtFvJtGLTZRKalFUGv5d8KzF2(0Zz9kNeAy9LDSsJPcAmyb3FLAWZ9kCQgdDTr6a1XcgNx6L2aBv0bacgWLhVHJECyV5PWvP3)DCeaaxUCzhNK(hMzkSXQlUJQWX7wYaJnAiOtiSlYnEvg7iFwItoP1I2ncf4iQdumC(4It2AckGYMwZU6tSDLK6Z0eDvLXPjKkSI7IeNIsIVMuUII3xWjk7zNymZqcmizi9PlSZvNRkETGHCxy'+'nIcEHQ0DkXcbXVQU)7DJiWMqUTY5(bittwDJLxZjcoqK7Yu0jX)PZR2MA95sVKNgF55mQ0Q4MIx06deKGk7kfWA70QSYut7tlod6EOOIIcupDQAmM6ErQd7NMxUToOE7rv4n8DJp2P103YelGC5NLwv0eA05oA7QafDeyKf5h1i1lJVuOudxh9wL7jV2KHquwqaueu9(d7g1IeSw7mb7wfKglvkbulCuFTi)vpTShEebfWe)qmgO7fFCTy'+'iM2RNFMlw6YxCQighK93qr1B0xZs7jRWia3UmIR3RvrEmu9)ojEVGw0kGdOiNzUxZm)nmoxOFyxWWy5W2ah659F)9mCo4OWGFbPcBAruTdkGiyIExzjBpgpy)49u)b2)jHQ2h8WDrXm7(hrmylnnzZBVWNReEckBUoh0HOXhB7lUCoDr1HqsSMtw6SIAbBBaARsDyN8IGv040QI)w6iOyZxsFQL(ChbqDd9xHvDCLDM)ZFCqFtWqEpuky('+'(8tF7vbOnz0LCwzmVTnp0nw9F5zECXvZ4MH)eVKMPpwvQXjkMvLgMICUKJve5Gmf6IvUryDKhTZQzCPCb2MNvJ(t6ozWOck14s5u(ICb4Z8ZRxEH6h4Dwl(NaFrXwKWzSVd2eT2O2lk8ahPvRNIFblMeuvdQkbMNw0u4E(PbB3hGvNBJ3Vuz8vS8s5HHk537BCgRw4moOd8((5yni8QAj5s6k55dkk55BB)cY5uc0BqyvM9IYbL55KNw1Q'+
'd3nDMTWGQVqnt9EvwOiV(T(ZEOam57XURsVwDKrKKjDEpf4Zh3A(HblKHRdK6bsHwTZbJNExpf15DCDpc)JLeF8lrmUtaFSZfQJguQ3SSotGTwrZlaNUgDLGhwPd2QN1YUK(FR2phtqkbm5ligf2tVzejj8NmXB0y8QpoxnK2yj3nWthqPut(4fk3d0EDFX0TTZg5tYtjBkXLOMjWS8)aDWAvqYL8FlL0jYzftzqbQ13Y30Rvo1vW9Rkvs'+'lXLYQfwM9TEMNwpCA25LL6Oyp963wbgMqMWYA0VywH52S3pMMeJ2zPedXlQd50Mqvs4p1iZLmLjv4FV5YXdrlAZqC8PtBeYfYv9dVD2nhH1wwy97A3btGTdMPTs2aqmegH0oVgKx(jtY6Ldq1JWILmymvzfbq21025drJm5tLseO)zBSPI80kFg2rT41JGTHQd7tLZK4Xhjp3(iAMednbHjHTa4jM(D2rolBdpAF2rVRSJKQkw8yIIw)PE'+'G9aDxO843eiGOg9Ia5(6sy8zPvzVzCo1tQP4uJu(A(wobTcE0HOcXa9EfxXytyzfr6C9aJvn6ctYeZRNlBBevPRbH)vFTb6Kd1qx2tZ9yoOASxpp(5M6DDTyE96iY)wpUemRm8S5aE2D7j0TzcaY0kdsY6VrGVyov6Ekyz(0znUnp8t7D)YIImfrgg94TXr3at7WNgSj1rkNjZt1m95f)jwifhaLWnTGdBcJ8XB0xH1xclja9ABaEB)12I'+'cxLjdAy9nzeQbbaTlTL)xECg)b(bPZFumvKa(MevuKlIMnjMBLljjvNKxeHqceS497Wazry9vW5ALfyYL9oyBc7X)qcQdL1z19X6x5s0nFpPtwZnpjPOABWtjtOx2DbSyZeHQQ5YqUHSxaEAdqoYv)zUBNHMBTDXHov5C6KOan7BxePbFxETxewyAUCoCr)M(TfBghPNiXe2wRCjtFFuAMOVCxp)CJ2qEGiW(xUXN1zOZvwAYPLIZCIhB0'+
')UQULVtmJj1cyKZQaXzTgbeAPLdN5u9yRNdtQBK3XqAx8zjZRRXxBMEXwC4lZ9H854VoSr3fRa9nvp6lxTeVagV)s1QyTXqlGf5rDqdOsWgbSWgv4FF7r36m)Rg2wy9QtAYtYK3w0ETMOYnGl(xsm5hmlFSCnf2K8Tv0Chppj2R(F7XogylecmJ0wyHbzbpPQhrwxWAMX3j9a4OG(w3P8bOVseFe5RwbOdktuvI7O2dQHwIsvKRUrkQf3W'+'O9tsOd6mHXFroFNxkLMuRNN80jE(K22uRn)wV3(eFTPkijfZKWRtyx4LNKgDj54ijFg9sOB0Agzc6DhibTnGZgSAFy4BMAqylDE8R1sTVUL)CvJ5kjJdzeNIS7OViPGPqlWyZhDEtOL8HQYixeuAng24yC4nR5Ezz8qZE9PUcEp(vQPaNxOQnxOWwmqikRQwASopTt3ZszbfcHl0I70)Qm7)K7EYUr1XIX2gsnNWJomdi8D3N7u2ZbzeJG'+'hLMu9h1JpMxUVRLeItPqwgXyJ3piYZhtVwv2AYtiR1bJ0RGniYT2CSp3mYgcCd3YbMdC4ccTjmPkG1DyWOBil7uv)X()cpD1I5hoZS6ctM4jOUXDRTKX2UJQLXfPSmOjrKnvv6OvdnGvQs(QKQsPhBdRucT6FB1OEX1LrSGJjml(tzcIuLGnopUSIihaNqbAvOpDgZ9tzqi88Ju)tt4GCWVg)qoWMk4zSDXI8kS1rokd0EWhcfYdI(hSQx'+'ch0dkS4gubO1k2V2V58uHNrNXeDbSXNBTrCMtLAv9BtTNsz6L(bRGD(AF5qMTcZQAXBR)6(s7CW4ldRWTYqhvIubdXhXetLhdGBVxoF29FgoIEhcCl(wulmcq7nAvP5)slbg9KU61D))eDXHFES29L9wVRzZLQ3j8pFXAWsRuM5Ay3PkuNV0bn237wWTOtfJZqjxyYfTrsqHu7smtAzc656hvTQofZg7d578jCRp4wby7(dSUsHY3e)BhT'+
'oNST3Z8zZFg5j(3sX560)uUVQKcJB1wd6FtQG)oyB8wI6MrZSN3Sl3KzLhevO(EWEYG3fnf8KqbhBDHxH8f57TZvis3crPwvlflhLefnhYazqvzA5e4aTAxI(v)YuYMJRqoKN1IqYKJeF2EU(ghRWU1ozJiH(9X9KE2L7tm60M)RGYnOPnAkFfw37bix9lyGEjbJDBroOKEz)abWzb(fUv4R4UdoxnGZltQ7RgT5JDoaLXlUgxSGaxQbmp'+'tf9JAYLCtmXDNqUIVy1fOk5zYj(JwoFVtM0s1zX4hw3qgRic9LFC7CoX6A)MEvOsuHMWI15WfAqZ2EDFdVdzvnRHV4DVYNpKr7Er(9Bwjdz(4iUXgPOkMfVDlNx0No)h2A4hjlFFaxs3b4aLyIfFkIrsHjk9mNDD0sgVX2qfNsNUyd)(NKaFM(XU0yg1(DtVKq9IbDNnVf)n8yfD0phjtigRGyfCn0a1TOvlOhxaAJsgRmY)AWlaMoQJ5q'+'jvsCEfigobzEWCZl0(lw3uiMbb5vuk4SNIpN)gIqaqmT8I4VexkMUKRu)sjq9bKX4bqYCYNzIIrcG8A)o7dsY60YMZ8TCxfZIO0bZCfYlqwM)rcJU5Xji6Td1PVzCDUklIEuu(02DF3mnNt9iqGee0ChkOZ4PHXhTWrJO1zgpY41bE46HEs5FTjPjHJ2ny8xNKvN4OFCu3oTPTyvufIJX4FQQc3JHqiodhhdxEp7)9OorgA9whyRWWWFmr'+'rfFW0(G9meVvglN1QRbUYXOTWsFtumhDJJ9te5cGiW)lKOnr(wy1UnxkcfAIhgR)MXwqE6rRVT(wEjkA0rIrPAmY3Yb8Qs(cojAF3wVBy(dLXXQ7pi4l0ZunxraNG4S2kaqCeBYehqk0u2XmLVxfOevxtrjoLs5KHJhEpzzl)JXLp1t6YHjPndBktKDkTvFjboI5Evklh1lDhi0uDa0E1UWHxvweB7K28n6aqIVdYDVWBeKyMVlcq1m)Cm'+
'EytEbrQSUngUgseaMZJ809rkjF3rVJsjFvWOXPAze)yjdQ7xHUOF6MHjoZTPZEanHN3esKyfZaAPNoVG3VOvQpXJFAy1akHcaip83h19IzwDRkjY9(BKLoMXvEAMqBEts5b3F6UX8rE93gsAdJDIDxSeEVGoaG2et5pGKffcM6GU9WDc7dMW8NSuUPDdaNGmgU23I9kIf5luVnPVvVeqcOgLK4kqrcW7qJClDGZWn4Qtl5zvAdhGOf2dP8'+'dekFs9RJqW576lQCjwjHS2l95rAl(X777ydEEP)WXYEzACWfpLIs37k)8zJ)7MkTJSS0r7PQ4mbCinBC4M3rIYECI0HvGOLIntvzD3ohdxVqbOIWC9gqPLVFlC(a(g9h2MSVG4aLVJPtmFeME2HRCK17nmob94hQqlvUC4fhuE8ySf3QhAfCtUwm)dEoxDispkrtBuOAoz2l1QXRqeaYo9u(WEyAysmb8be1JkJnmOqqFTaZ6umn9L(HWW'+'mZVSSUWBh2jjqOctpZzn9UHNk47TVQWqZZpJJtPiD26uGUefqAjqn7TusOfoIKB0Im06pysbjP8xB3pGtt4or456Yclpv)Z0xvY9q89aJKFjxf8IN)RYBkOcwqKs(WHe5(24XteUb2q2PrVNorCEuCh6NK7Xtv0KjTzBf3s5p9UUVHUMhBRXSJgxYY3LILC2WZuBewL)vmR69KXG9q9tUTPIopJbtB4N577cv(RG4g(7Cy7P6K)pXO6INu'+'S(4mkKfW21m6cOfLU7UP4AHIF2HvjXEBfdbs5oworDmxqMOBx9)kDjNoIm(LdDKcsfASBvi(9m592TCreVOtQBk9GDI8on8YzdOWo(bz46iFx8asA2yaNMMYI1Cj08BOUEpXu936k2FuWvt2M6mV57ic36aXYVXxT7KuYxQnrBNZjQhCcsTy3iu2lm0qkzI6LZ6IiaOy3spN)Zsukz9VsjgJ2N)vH7AnvLiECH12ukNV)RuZLgRDN5je7s'+
'0(cIj3Usb4UnuMuI(qsA(imU8z7Ejk0IhwdSwH9B4FYyk72u)lnh7WwwHWE7XgvNdEh92Og2swY)vaEqKST1S5kdtzIPaTzAikGAN9tAxNnkbK)MJTbDVskCtybipN7Sn1y59raVKZlYj22VjPohw3BrY9QbI8xl71UsuPU0oRYPp7EAq8RpXMtGsT(b4b3UledwKh5FiWDY4pK6NaMHh5Fwo(tHSlRa0)wthu1tMLNUtCVFVtV3a9zQF('+'QFG)n)p)8R(DrdDGqvxQQ7phYfAr)605DuXkRu3XSX9jOI0tw2hxds64RLZUYVyeU2pFiaOCKLWOXJbbLN)x(7KW(0PiWFbuxddm1VHWzeGlT6rHMODHpf4LHAWloDwzktuhUTyQo5QdS94XN8y4yPFhbNXaUXzhsnpmMUnUvF4KIetMe541U(0ND4ep9B0Nr2bjyoIHnepzPaHzZvd1CYLTKsd80sJjM7B4RrmOQchnLQCQuSfApW6(h)'+'wZ5dKFA1ff)S)Jlms9kR8fVz04gYuRTZfuNzbZs5g1S2EZBB)k(s)nlMyufiyctZqSC6ANm(ibV0yXX3qsRLcAyJe692Hs3emnvOqbHMnIQvWYD8rzny1vGgQLMQodR6KnshM0rO7KGmiG6cF(nM0ClZiAxPlBVvgLuwE8i7TZntAk5xpoNWTIfrIm0ZtuoWOMPn)qoYBXQ67nt3S4fg5Yh3Cny95fQBO8Zy2bs9g5RL22JnZCrCYEv1fg'+'oj3TkcbsPW9qD87Uq1yH)N(0ROnz3NJCzAJUt0TwOM8Yb50x7wXqRL8Ix)aXgYKxmoD))2MzqtddjHyfs6ltLfU7Swd(gXXRFe9(yob6IFx8ogR1evGPfUlkx(vTtf5QyMm1fGMd5OSsq2S5BXgUKBM(oIjI)Eit19o5C5AqAhVoAH9(utQZzdSAv65g9OboTvvqcqbKpspswLVV0PtF9Qp9hhmQKMbkXGZZ7uWQ3CVt6tgYtx6gteNly('+
'q8(45XN2Cj4PIo6ighDiF1wXRjv9mtJeu6BsCzd85DhaGDdxpikGeSQ1OFoQXmqss(Kv1lRlXdVZ4LBj9Jrf0cgvZvSiKvKskVB)by4pHVvh6mChzFmgRqUUJ)0DcDb0jIodssZmOgY6tYNCH)cfTzfdPezRtphsEaQ9NsG6Aoaow#';
 ttMarble='T1s30U300000))))~'+'gggggggggggggggggggggglwgwgghlhggggwhwkggLLLLLLLLLLLLLLLLLLLLLLNjLLLLLHTLLLLLL5LLLYY8YAYegAYY8AYeegY8g8gkgfggekkcgYYeggegAYLKLLKLLHHLLLLLL55LLHLLHTLLL5LLT5LLLHLLHHLegeeY8AgggeYY8Age8gggggMgg8hgegggegggYggg5L5LLLHLKH5LHLHLLL5LLLLTLLLHHLRHHLrKLLLL4g8gA'+'AggggAgegYg8gYYeAgkpggghgggggAghjeeeYHLLHH55H7LLLKLLL5LKLLHHKLL5DLLLLKLHNL5LLLgYgggoegheYgAgYgeeggggykgggeeggeAYgv(gAAg5LHKKLL4H5LKLLL4L55HLqLRL5LLLLL5LLrLhLKL5geggAAYghgggggegAggggA(gAgAgggggYAAg)fYYgHLL5HLLLrK5LLL5LHHLK5n5LLHLLKLLKLHLrHLLHHgg8YgYeY'+'fAgAgggYggYggwegggYgg8gYeghUhgAggLHLLLLLKbHLLL5LL4LLLKTLL5HHLLLLL5LPrj5HL4gAYge8ggkhYWgggYggeYgYhgggggYgYggegRlegggHKLLLL5LtKLLLL5LLLLLLSHLLLL5L5LLLrSzHLL4LgYe8AgegcY8gAgge8ggegg(YeeggeggYegdMBgeggLL5LLHLKLLLL5LHLLLLLLPMLLLHKLHHLLLzTr5LHLY8gYeAYA(AYe'+
'eggggg8AYgkeAggggggAAgeocgggYLLLL5LLLVKL5L5LLLLLLLCPLLLKLHKLLrH)trLLLLegY8geAYwgegYeggYgggggAAggAggggYgkMfFfgeeL5LLLDHLD5LKKLLLL5HLLLKLHHHLLLKL5xzrwN5LLgg8YYgggwggYAggeeegYgYkYgAgggggggAgwhjgYgLLLLKLL4rH4LLLLLLLLK5LHLLKLKL5LHHpriMNLLKgAgegYggYhg8ggYA'+'gggAYekkegggggYggEg)xkAggLL5L5L5Lt4LL5LLLLLHLL5LALK5LLLKKKrzLlRLH5gYggeeeYilYYgAYYAgggggewZYeggYgggYBwzkYggLLLLLLLKrRLKLLLKLLLLKK5LLLLLLL5HLLrLNBL5HggAAAggxkgYggegggYAggYgYYggggggAYwgzzjeegLKLLLLK5JSLL45HLLLT55LKLL5HLLLKLL5TlNTLLKggAYYgAggUgYgggeggYg'+'ggAgegAggeAYeeZuyBggg5LLLLLLLLrJKHHKLL5NLH4LHLLLLLL5LrLSLLLL55gYeggegYwclhggggegggegYAg8ggAAYggYggghgegLH5LLLHK5TL55HLKLLPLKHHK5LLLLLLHILzLLHLLKggeg8YggggfhegeYgggggggggYAgeYggkgAhgggYYHKLLLLKLLTNIL4LLLLrLLKKLLKHLLKH45TTpqMJKLgAggYgAYgQdAggAgeeggfggY'+'eggggggggfg(h(hggLL55L5LLLrTLLLLHLL5L55LKLHKL5LKHSNVNNLLLHggggegYgegggAYYggggkgeYgggYegeYgcOhzj(BggH4HHLHHHLLj5HLniLLLPLLLLKLLLL5L5LrrDVJLLLgggAAgggggwhgegsYeecYAfAAAgggggeAZisbhvgeLHLH5LKLKLnMLLKtLLLTLKLbrLHL5HLLHzRV)KdLMAgggggAYgAgl8Ag8gYgkgYgeYegg'+
'gAYAkhlxfwgggLLLKKHKLLLLRLLLN5LLLHLLLL5LKHKLLbqoLrNLL5YgegAgg8gYglgYAfgAAgBAIAggeggYgeggllljhBwLT55L55LHLLVKKHLKL5rKLrLLKL5HL5LqNVwirKKDgcgeeggggegsYggggegghegYgkggAgeg2gngxggwwN)HLLHHHLLKSLLKLN5HLHLHK5LKLL5L5LPt)s55jrfegYAAAggggwgYgY8gggAAggYAggghgg'+'ggArlghwkNLLLLLLL5LLT4LLKLLLLLHLLKLLLLLLHHKrNPLHNxfAAgYYYgggY(gegAYYgYogYegYgggggggABg(ggukLzLLLLLLHLLjLL4HNLKLDLKL5L5LHLLLLLLLbLKLzkgYggeeAggggZAggeegggYAAgeeYg8AgeYggzgggIHbL55LLLLLLrMKLK55LLHLLLHLLKKLLLVqLrRLLNLgwgggggggggglgYggggAAg8gAYggAgYAYwfA'+'lf9YgLLLHH4LLLLLj7LKHHHHHLHLHKLLHLLLLLLFpKLLLKYgAgggeggggwfgggggggYAYgggYgggegggwkgZgggLKLL5HLLLLKHNHH5LKKLLLL45LLLLLrLLTjvpKLLLgAlggggeggggdggeggggegegegeekAg8hswAxhgugHLJLHLLLLrLKVKKLH1LLLH5HLLLLLKLLHzrML5LLLAggAgegggIggjYAgggeYgAgAgeAgggeggQkgshCg'+'eLLKLL5LLLr7LFLL5LLLLLLLL5LLL5LLKT)R5VPLL5Ygggggg8YOggleee8gggggAgggeggYgghw(gwQgAgLLLLLHLLTrHHPLLLLHLKLLLLLLLLLKbL()BLDLLKLYgYggggg8YgQ(YgggggYgYgYYYgggAgYsg(ggggYgLLzKLK5LLLKKzKKLHLLLKKLLLLHL5LHHRRNRLHLLnegkggAgA(gggYggggAgeYg8gggggYYQggkrleAAAgLLL'+
'LLLHL9L55z5LLLKLLLLLL4LLLLLrLLVVLLLLLLgggggggegggg(fgggYAggYAYggegeglhhfw)wgYeg5LbLL5L5LLPLvNLLLLLLLLLLH4LLLLTKKLlQbHK5LgggfggeggekgAlhfggeggeWAggggAgghAgwwgggggHLTVLLLL4Lx4rVLLLL5HLLLHLL5LLLrSLLD7JK5HHgeMYgYAYgwzhYcfwhYgggAAgYgggYghgggwggYeggLLLNLLL'+'LHLNrs(zjMr4LLKLDLLJLLb(5L7LTTLLL4gwwggegeg()fxVgwjggeYYeeeegAgugfgjggYAAYgLLLNKLLLKGLLl(rgxLHLLLLLLLNKLNVLTLLpLLLLLgggahgAggwlhwtl)keAgeeAAggggYgwhYggggYYAg5rLNLKL55Lzsk(ErTNKLLLLLrr75LH5LzHHDLLLHHgggggggggBthxxlQogkAYYYeQgyggwgAogAwgeAggHrTNKLL5HKj'+'skjRJrJJKLLLLrN7LDLLLLKLLLLKLKg8gjAgggggwlw))kkwkggeAAcYggggegyBggggggALLpFLLLLKLKzNpzJv6N55LHLLLHnLHLL5LLLL5LLHggUkgggYAYgh(xVlkhggggggg(ggggEggYgAggYYgLLLLHLLLLLLrLt(DPLHHHLLLLNLTLLJ5LSHHHHLKKYgwjAgYgYgggVgsdQggeggeggwYggglgcAAggAggYLLLNLLL5LHKLrnz'+'SrjNLK5LLLFTLLLLKPHLLLLH5LggghgAggggYehQwRgwAggegggggkggdAgwYgeeAggLLLLLLLHH4LLzCjNJb555LHLLTjLLLLLLqKLL5LHHgggggYQggg8goh(fRwgYgggggggegYlYecgAAgeggLLLLLLbLLLLLLrvNiLLLHL4HLLLLLrLLLzHL5H5LKgggkeeeeggggwQVxgggegAggAgfgYehAcQAgggggYL5LDL5LLLL5LrKT7LiL'+
'LKHLKLrNHKLKHLqLLHLL4LggcgggYggggYgZwlYwAgYgYgYAAgggggjoZggegggLHLTLHLLLLHKLLbnLjJ5LKKLHLN5LLLLNrKLLL5HKggggggeggggggggVggfYggAYgYcgAggYZugeggggYLLLTLKLLLLLHLLryHLLLH5HLLKRHLLLKKbJ5HLHKLcgYYgAgggggAgggQggweggggeAAgYgggAgBggYgAgLLLLLKLLLLLKHL5LTH5LKKL'+'HLLLLKL15rNNHKL4LLgAgggggggggYhggglkgcgAYgggeYgggge8ZggYgggLLLL5LHLLLLLL5LVjLNL5LL4H55rHLKH5rNL5LL4HgYgggggggwgwYges)wkggYeggegeAggggs9YeeYggLLLHLLKLpL5bLHTPMXH5HK5LLLHLKLHKKtLLLLLHLggAggeggggkkeeIgggFgggg8gAgAZAggAQZeYgggeLLLLL5LLTJLjLKqb5rwJ45HLLLT'+'SKL5HHnLLKKHKLggYAAggghgkxcggwvgEkggggYYYYgYeAgghYgggAgLHKLLHLLLrLFNL5HNKLLH45HLPKLLLLKLzCL5L4LLgggWYggggQxjfgggkgggggekOggAY8gYgwleeYgYgLK5LLKLTLLNNNLLNLLz45HLLL55HLLHLHnUTLLLKLggggggAgggwkQYgQgcggegAAggggAgAAgwdAggYgg55HLLLL5LLzwqLHLLM)HLLKN5HH4LHK'+'H5D)KL5LLHgggeggYgAgsktgAggleAAgYgYgghegYggejhgggggLHH55LNTLLDxSNKJbVLKLHLJL5KHL5LKKTzHKHLKLggAgghehggklggggvDggYgegeeYwheegYgU)ggYggL5LLr4rKL5LnL5LLLNLLLL5HLLLSKLL5LLiFLKL5LgeYYggggAgYQggAgggggeggAAAgggYgegggxegeegLLLLKLLLLLrDLHLLLTLTL5LLHLH55L5LH4n'+
'pD55L5AAgegggYYgggggggwcgggggegYAkggeAggxFhegAgHL5LLLNKL5LLL5HLLzLLLLH5LHKLLHLKLHq(LLLHHgYgYghAgggYggegggkgAYYAk8ggggAgYegAt8h8ggLLHKLrLLLHLL5LKLLR5LLHK5LL5TNK5LL55)LLL5LgeegAhgAYgeegYggYkgYegYgYgYAYhYAAguwdYYee5LKbtJ5HL5LLLLLLLzKLLLLKKLKLLNLHLHLbVLK'+'L5gggezghgggggggeAg)gAgAgYgegYgUggYAgfjeAAgL5LLrNLLLKLL5LL5H5LHLHHL5LLLLrLKLL5LVLLLLAgYYSjggeAgAgAYgggggYgggegYegggAeYghSZeYgHLLKjbLLLHLKLLLHLHLKK5LJLHKLLHLL5LLJzN5H5gAgAwxhgYggYggegggYggeeAgggggBYYhgYEYjggg5H5LHLLLLK5L5HLLLLL5LLLL5LLLbLLLLLLSrNKLKgg'+'gYwsvgeAgeggYAgegggYgiYAggeieudYeYAlAYgHLLKcNNb5LLLLKKHLLHLLKHLKLLKL7LbUL5LHFLL5geYgwggvgYgYegggggAgYgAggggAAgBgYeg8giYegLLLbjNRDHLLK5NHKKLNHLLL5LL5LLNHHLLKL5LLLKgAgguflkgegAgAggY8agggggAggge8gQggYgeY8ggHKHnDVqILK5LLLLLLLTLKL4LLLLL5LLK55LCLrLLLgYggkr'+'ohcggewgYY8YAggYggYAgAgYeggeggAgYYg5LLrRLlsN5HLLLKKLrKHLKLLLHLHHL5HKLHHHHLLLgegkkkuVoggggggggeYAgggZgggggAhgYgAggAhegHL4rxDrKTGLKLLHHHNLL5LjLLKHKLKH4L4HL4L7LLAggQltUxegegggAggBgeeAghgggggYggeggYgeeggL1HrjErDDL5LLLLLaMHLLLLLL5LLLL4L5HKLH5NLLeggUthZxhA'+
'geggeYwgAAgegeYg8Y8ggZgkAgAgkgg5LLnzQLLHLLLLL5LH5LL5LL5LLLLLHrNKILLKLTLKgegQhlwhhYAgAYgAAgeYgAUggAY8YAAYYAgggAoggLLLKLLTTKKLLKLHHLHLLKLvHLLLLLKTLLLLL5HT45YAgggwcYggegggggYAAgYewlgYgggg9ggegAgguggLK5LL5TT5L5LLLKKKLLHLLTLLL4L4rtJL5HLH5rHLgYwghgc8g8gggg'+'gYgeeAggggAggggI9g9gAYgeABg5LjRr(TLLLLLHL5L5L5LHLLrKHHLLqNNNLLH5LLNLggwkkgwg8ggAggeggggegAQggAgYegYighegggYkYLLqxztF7LLLHLLLHIHKLKLL55LLLLLLTL5LKHLLPLYgQlhUlgYgAgggAgAgggYggYgg8ggeggYgAgAY8wgL5rS)xJHL5HLHHLbLLL5LLrLHLL5LLLKLLLLLLL5HAghprMlgeggAggegeA'+'ggeggegkgg8ggggeYYeeYghLLLrUzS5LH5HLLLK5HLHLLrKKTL4LLLLLLLL5LKHLggghhgtgAAgggggAggYggggggIgggggegc8ggYggfLHLr(prLKLLKLL4LL5L55VLL5LLLLKLLLSLHHL5L5QggghwhggYgg8YgYYefggbgAgfAYegggkUgggegehLNbLpjqJHKH5LLLMKLLHHLLLHLLL5LLLHTLLKL4LKljggFwxlggAgAgggAAggAk'+'AYgYYeggggggeeAYgghLVHLzt695LLLLL5LLL5LPLLLLKLLKLK5Nr7LHLH5LhAgwhTggegYgYgggYYgggAwBYAgYgggeqAgAggggZzVLbsrrLLHLLLLLHKLLLLLbHLL5LLKDLLrHHLKLLLNYYglggBggkggggggeYYegggeYgegggkQYAkeAYYvzTLHLLLJ5LLHHLLKKLLLDLLLbKHLLLLnNNr5LHLLNtegewhwgggggggegYeeegYk9gg'+
'eAgggggeYhAggggLLLLNLNKTLLLL455LL5LKrLKH5LLLLLLNLrJLLHLNggQgfYghYgYcgggg8AggYeAggggeYggggkgBYAggcL6LLLLjLKLLLHLLHLLH4LLLzLK55LLrKTLLKTLLLLgggg)kxgkAgggAgggYggggYAgYeggegkYggY8YgAgLLLLbn(LHrLLCHLL5L5L5LLz5LLHHLLpLLLLLLLHLAggolgBhgaYewgYggeeggggugAAgAY'+'ggggAAYgYgYLL5rQLtVLLLLLLLLKLLLLLLDHKHLKLKLLLLLLLLLLgggghgvpfg8YegggYAAYegAggYgegggggYegggeAg5LLLtLjULLLLLL5LLKLLLHLL5L55HK5LLLL5LNLH5ggghAg(x)AggggeAggggggYggAggggghAgggwAgggHHHLTLLNALL5LLLLL5LHLLLTKHHH4LK4PLLHrJLLHkggegYsj(YBgYgAgYgggeegogiggghYggg'+'gQQkdggLKKL4Tt7RLKHLLLLLLLKLLKTLLL4LHKLLLLnTLL5LhYgAhljjkehggggggYeYAgAgBggggggYgegghQhgALLL5LzszLLKLKL5LHL5LLLLLLLLLHLLLLL4CrKtLLAggghcRcggkgAggggeggYgYgYggQg8YgAgggghPgYLLHH4TNVJLJJLLHK4LKLKrLTLLJLLLNCL5LLLLlLLYegghcrgggkgYgggggYggAgtggkhAgwgfeYYgA'+'vhgL5L5HLNMaJpMLL5LH4L4LLHTrLTLLLjLLLLLLNNHK8gYegggxggwkegwgggeggggcghxhYYRhYAgeggjhgLLLLLLNHLrlHLLHHKHLHKLKTLRELLrsDLMLLLlLTLgYAAgh8kgOxgAAggYgAgYgAdTkhg(hRdggfkcwgfg5LLHLKLzKrDrKHrLLKLLL5rzsxLjhqsL5Lrr)KVN5gYYgYgguEg)gYgglgYeAAgYowkg)(gUhwehQgkgRgH'+
'LKLKD5j7rKLLLnKLLLLHLzLlRLIrtvLLVTrLxVNLgeAYgggweggBgg(xgAgYggAli)g)QDlg8YYkxlwggL5LLLLLrLLLMLLDbLLHL5HLLDfSLrNRLLLLLMTNTLYgYgggY8hgghgAwukYggegYhh(txQvf8gegghxThgLHLHLLKrLLH5LL5jJL5LLKTJrsSNzVVLbLLLMLtrL8geegggwfeggggg)gggggYgwtkxgMhcgeggggtTkALL5L5'+'H5vLLyHLDHoLLLL5LqLTPrJVVL4LKTrLrtRLgAgAgAgEAYgggwgkgggggggdc(ggqYfgYgYAgUzgg5HLKLLLrJLzLLDTzKLLHKHnUNLrKrLLHLLLLnJFDNggeYYeY8leghgghgggYggAglgQggVhAgeggggwwggH55LLLLLVLvKLTLLLLK5HKLJrqLLrL5LLHLLLLVLDgegg8ggYthkhYggeggAggYghgggchgiAgAgAggrggLLHHKLHL('+'MLLL5LLL5LL4LPqLrDrMLLLLLHKLHTrTYgggggAgwlYgggAggeggggekeggggAIggggYggwfYLHK55LLL5RLLLHHLLLLHHKKBLLKLrKL5LL5LLTBLLgggggAYYe(fggAggYgYAgAxlYeggwZiggggeggwhgL5HLLLLLLCNLKKLLKLLKL5bRL55LrrLrLHHLLLDTLYggggggggwgggg8ggggYAghhcghgAAggAggAgc(ggLH5H5HKL4rLL5'+'5LHLLLLKHMLLLHLrJrKLLLKHrHLLggggggAggohgggYAAgegYg(egYgeghgxYggggggggLKL5LHH5HLJLHHLKLLL4L5RtKLHL55LbrL5LKLrLLgAYgYAgegekggAggg8ggAwUlheQgggffgggggggggLLLLLKLLLLKLLKLH5L5LnH(LLLLLnpMLNLLLLLLLLYggAggAAAgxgggYgggggAgsgAgYYg)ggghAAggggYL4HLHHHLL5LKLLLKL'+
'LLHHLU5L5LLa7LLxKLLLLLLLggggAAgYYegggYeAg8AggY(jgg8ggzggfhgYgggggHL45HL5LLLKLHK5L5LLLKy4NKKL5rFLLLLLLLLLLLAYgggYgegggUgggYggYYgAheggggQ)hgggAgYggggLLHHLLHLL4HHLLHLL5HL5LLLLLHLyxLLLLL5LH5LLYAgg8ggAggAxYYgegggeekkgAAggh(ggggggeAggeLHLLLH4H5LLVLL4L7HKLL'+'HI5LLL5)(LL4LLHLqLLLggAgggggegeoeegAhgAAggkggwggftcggggAggjggHLKLL5HLL55LL5HLLKLLHLRLH4LmsTLLLL5L5rNLL#';
 ttLeaves='T1830M200000))))~'+'4H40000000Y00gggggAYAegILLLLLLL519I8egggggg4LgozzrUV54qH4eggggggg2GIG5000G00aW2WwwwgkcC(ggALLLLLLHHG8e0gggAeg2IbWSrLTRT8KzKLeggAgggAY4K450005009aAWkhxkw4vgYeALLLLKLL40g02Y8g0geGfK9NNtLj5orTKHfggggegAeL55X82G58a4KAghkwkAHww2e2LLLLLL50eA0W8Ye022KK50rTN'+'TtHCTr5LXggggYg2OKH4G4HG45fYA8owgxg2ixkxYgKLLLLL1KgA828Y8422HGG4TrrrNIrLNT9bggggAAeML1W201455fOW0kkxghfwwkkgAKLLLLL0aggYa8W022K5GGLNNTNNrTTTNK1ggggg28LLL995H519fA8wkhkkEugwwgLG4LLLL5GfggAYY20eGL1HqTLNN6RTRPS7eAgggggWQLLL1H4K4ee2XehwhchhkkkkkKKKLLLL1H'+'gggg9AAa2LH8nrTPTrLTNNNRDcgggggAgMLLLG544Wgg0XwggkkxjghhhwaKLLLLLGbe8gYWA2A4HL4trtTNNLtrrrTbegggg8YgLLLLKH05age2hxewghxkvwwwgGLLL4L5Lfgge2eW2gKL1rLTtTrrSrTTTzXggYggggQLLLLK012agAegjhhkhxwgkkk0LLHLLLHLggggAg0YA45csLrLNtLrTLNN8ggggggggMLLLL4HKHegCnilxk'+
'hQxgwkB4LLHLLLLLXgggg82Ae8KOGTNNTrTrTVTr4gggggggegLLLL051LGeg6kgkkkhkhkkkJKLHLLLLLL9ggA8WY2A8HLNVNTLtTpTTLNeggggggggQLL5KaGH54ewkhkk(kQgwwwkGLHLLLLLKLggAY8ge0KbmTrLNNTTTtrLTbgggggggggMLLHHIGGggogkxghxwkkhhhQLLLLLLLLLbAggWYeeGH5TNNTtrrLNLNNTggggggggYg'+'LLLKHHHXgYkkkkkwghkjhklKLLLLLLLKLfggAYeIYaILNNTNtrLTLtTLdgggggggggQLH54HG4fIXhhxghxwwwkwwELLLLLLLLLLggg8geC2HbrrrrmLTrrTTr5ggggggggggMLLL4K4LfAwQ00WgxkhhwwwLLLLLLLLKHbggAgAA2GL10Kb2trLNNTTTfggggggggggLLL1G44LAILbg2hxgjkkkkELLLLLLLHLLfgYgg8gYGLLLH0rLr'+'LTDNNNggggWgggggQLLLGGI8Xeg008uwxgxwghhKL000LHLL5LgggYeY8YKH001KTrTrrTtr10egAgAggggMLLLHHHLbgA9YekkBxghkwwgIL4KL0HLLbgggW8Y80bK14GSNtrDNNTTTVYggg2egAgLLL555LKXgg8AeghihecxWkkKfGL50LLLfgggY228YIH400tLNt9TtbKN5figg0WggQL5L1HLL5ggg8Ikxhh8mgAbhxK5LL10KLL'+'gAggY88WIbI44SLrrn9StfmrfgegA0WggMGGLG1KK1YoY8owkvII4hJLwA5LLL00K5b2YgYe8AYILK400SrbS4sLIITgAgg24Wgg55KLH845Hbgg011ihe4bwKLkIKKL500KLf2egW85Y2bKHGeI2MCZ2qbe2lggggGGWgQ10LLH84Hfgg84451K2XaBLHfe4LL100KKg0eAe8bY0LH5fA19YKYaKfgAfaggA00WgM0GLLag0H9gIf0e81'+
'0a4XMILDLLLL108Kb2WW28KLI8JL55A4Ib0aIMga8IYgA2G0eg50GKLe8G4eYee2b2XG51g9LLGLLLL0W0Lf0XWW8L9A5KL5HXeIK8H1bWIWAegg0108Q10LKKeA3e2eIfJ9G2AIeC8HLGLLH5000L2002A2HIIL50042LI9YKKEgAEAggA000e60050aeeI8Yggua029IH4IKL1GLLL1WW0501YYA4L9KLLKKDKb2HGAnKA2008g2400e'+'00GHHG1gYgAAAx41XIK219KL000KL0000104WeGL2LbKLLr1fIYAIH1ee0000000GG800KHGAYgggKgYY84I1HGGaK100002020G010YeKIK4LKA539A9eeKgagA1000GG0000005LXgggYgggWA28LK02HK55800000000440YWKHKLfKKKLXA24KbI8YY004080041000LKaegeggg200HY2511KLL202800Y00000AAeiILHHH120fe'+'G9fI5ggA0200010000024O9LYggg0bg88KK4H8HK4X00W00000041AYA5L5bIXW8AAAAa8AIcA9000000GG0202LSfgggIYK95552I415ba200808080000W2eEKGAL1421XWYIYI1gg000000040080W000fQgYIAbGHKHHaGKL90M08W8020000010K0LLK522KeAYGAg4W81f3100000G00800KAAgg2YYIA0Y8128H9G5700202000'+'0000WI2La4Yea0Lf8fYA2IeAk100000G01W08Wgggg2YK4fY8K8GH2509H5W8020800G040aK59LW849Y85Age01g1fk1000G400G000KLYeAD45HI9X259W2TNHSN20800080000aKL5I55YI88IYY0gWkkkug300010000W0WgeYYggWGKA2baKb400TZrL0W000W0000GaKnI4L18A2I148Ye8IWAfx2G040G00008aggK59295H5e2'+
'LI9KIKOJNT8000200440GLHL5fM2098LeYGWAY4AEkk6000200008GAgI2gY0YGA4KaKK1YW2STTN0000000G00LbK55LXIf8Ab44AIXKYgww26044001000gKbAgA11A85H0552K5IHqr500200Y0000KLL5ILLYI2YeKf2H5YI8mg30010000W08eW8fgYe0WgW0GKG9G5H4LS70000080000W4KLGLLXAGL8L2K8L0HgYe600004400'+'0Y054geYg21aIIGK54HgK4G8708800000000K908L55YAGLKA8bI2AAga200004000100824KbgA41Kf01La0a222a000W02W080008BY2g4L8W8gWI1aeAYYI5K00400000000gI4HWaAIK8GI4H59HYaG450000802800tLL02aGL588Y2Af81HW4g4900G0000000WeeA451b8HK4A584HHK55490000W00W0008Lf8YWeiG8822LYe'+'eaW25900G040G00400eeA0HWAH4K4G9KKKaeG190080000000840KHeWe8b828e8A0448KeA2010G001400010gIG4G5H454H2455LIK4110080W00W00G105e4AK1822HY2YYYe44f2400040G0010g00405a2545Ha4XGG915H47WW00000200K400g0A4222Y44YeK0H992f0000001000Wg200G584551454KGK94HIX522WW00800'+'0KL10g0A922Y8982g42be8ew1000010011Weg04G284X4H44414bYK8LG50020000000LHL0Y821e82AY2eA9Y8aWax600000100WegI4XG415G41019G8I9YK1qL30W8W00W00HL5W8822g0YeW0I4YWI2YwwgVR0G0G402gYeKHK455G104H5bIHHaYKTTNL0000000GLL1W8802AWe2X0X8GY8Y4kkck20001000YgA5HKK41L10HWG'+
'4LY4Y4LRTNF0000000G551X884Y0WgY8aYYYWY8XjwgB0H0404G3gg2HG411H410H4GXG9ZKGLTTt0002020HGKKW8WGYGAY8YefGA8E4Kwkgk2001010L5ggIGKK4H04H41H855S55nT)T5W0000040Gfae882Ye8Y8YKaWWgA9XhgwA00000000K00GGKG19K4H4eWKKnT9KrTTr0280800f2WW0888e028W4Ib8AewEAiwkw0000404'+'8GHGGH449G5HK01292LqL4ItLV18W0202e8GAAW822I0I8eWIHY2ahZYkhhE0000000DK02IH45HK54KGH5a4fGtGMLtTW00008048eYWW82I80Y8e05A2HAeIgxkg000W100eI40HHG41KK4HKGg4bKgA04qTt10GmW10OL8AYW88Y284Y88KYW4KKL9ehg30Gu280GIH42HG44H545H4a2f49MgA8Nt5W0KT28WMP8YWe822W42YWAKY'+'8HbIK9kkA0Whx43W5A24HGG41LG41H0aYKGfI4AKTtrrrr5G0eL52Ye88Y084YW8I024LL9LukgxwgwWL0IeKH1HGK4H951HG48IbgAAI2LtHTTt906OML9WG888Y02YGg8830KGLHL(kwxkg3484YWeKHKK44H51H4G408jQgGASTtrLVd8A041K1W8882Y0XY8Y8A24H55IjwoghBWGW2X2eAGHK441HGXGWG44YfggKItrTNtHeGL00'+'G5GW882YWeWee882SK5L0bghhkkQAGY2fWe22H4I5HGGGGG44ucgAYATNNNTTLXKL0085I2W20Yeee8889oLGILIvkkkpQcgWAK80ge2L0LYGGGG454ahhgKGnLTT0qTLbK0IX01L0e28IIa8aWY2LtHLIbxkQKehggaG10H8gAL05244H48H0vkAeAALL78Wr5L5HW2W8KK18YYAAX8A2Y8TtLK4kx6LHuweg8KXGHWg8420142H44X0w'+
'gRgWKt0gYGTGLL8W0Y29L8YAX8YW8AYmTrLHa00GL4Gk4ggI414Heg841G844144XgkhhAggggA8G3ILL018AAI48YAA20I222tTNrK8LHLK4a14ggAH055e2G40145541XkxgkZIbgYA02G5KLL00Y2Abe8AY4192YGTLrTNXKbG9G4gggggY24159GG421H025nkkxwg8agGL90LLLL5LG0Yg2e80YWYG22YTbrTLNL5GL0WggggggeW'+'#';

{TPenRef max dimensions 65536Wx256H}
Type
    PPenRef=^TPenRef;
    TPenRef=Record
    minY:Integer;
    maxY:Integer;
    rowY:Array[Byte] of Array[0..1] of Integer;{StartX,FinishX}
    {Other}
    Area:Integer;
    Width:integer;
    Height:integer;
    HalfWidth:Integer;
    HalfHeight:Integer;
    ZeroWidth:Integer;
    ZeroHeight:Integer;
    {External Use Only}
    Solid:Boolean;{Hollow/Solid drawing}
    Full:Boolean;{Internal Use, by External Host Only}
    end;

Function FillPen(Var X:TBitmap;Var Y:TPenRef):Boolean;
Function WithinPen(Var Z:TPenRef;X,Y:Integer):Boolean;
Function StartX(X:PRGBColorRow;Y:TColor24;S,F:Integer):Integer;
Function FinishX(X:PRGBColorRow;Y:TColor24;S,F:Integer):Integer;

{TBrushRef max dimensions 256Wx256H}
Type
    PBrushRef=^TBrushRef;
    TBrushRef=Record
    minY:Integer;
    maxY:Integer;
    {Pixels YxX}
    Pixels:Array[Byte] of Array[Byte] of Byte;{256x256x256=65Kb - shades of grey}
    {Map X,Y -> LocalX,Y}
    MapX:Array[Word] of Byte;{65Kb}
    MapY:Array[Word] of Byte;{65Kb}
    {Other}
    Area:Integer;
    Width:integer;
    Height:integer;
    HalfWidth:Integer;
    HalfHeight:Integer;
    ZeroWidth:Integer;
    ZeroHeight:Integer;
    end;

Function FillBrush(Var X:TBitmap;Var Y:TBrushRef):Boolean;

{TDrawPointEvent}
Type TDrawPointEvent=Procedure(Sender:TObject;X,Y:Integer) of Object;

{TRepaintRectEvent}
Type TRepaintRectEvent=Procedure(Sender:TObject;X:TBitmap;Y:TRect) of Object;

{TToolClassEvent}
Type TToolClassEvent=Procedure of Object;

{TPixelInfo}
Type
    PPixelInfo=^TPixelInfo;
    TPixelInfo=Record
    {Pixel Position}
    X:Word;
    Y:Word;
    L:Byte;{Level, Shade Depth}
    {Image Rows}
    Rows:PRGBColorRows;
    {Image ZeroWidth/Height Dimensions}
    zW:Word;
    zH:Word;
    {User Color Info}
    A:TColor24;{Color A - usually foreground color}
    B:TColor24;{Color B - usually background color}
    T:TColor24;{Temp Color for Routines Use}
    Transparent:Boolean;
    TC:TColor24;
    SafeTC:TColor24;{SafeNonTransparentColor}
    {Scalers}
    aR:Integer;
    aG:Integer;
    aB:Integer;
    {Internal Temp Variables}
    atR:Integer;
    atG:Integer;
    atB:Integer;
    atSet:Boolean;{Defaults to FALSE before any operation}
    {Size}
    Size:Byte;{0-255}
    {Strength}
    Strength:Byte;{1-100}
    {Scatter}
    Scatter:Byte;{1-100}
    {Style}
    Style:Byte;{0=none,1=red,2=green,3=blue}
    {Solid}
    Solid:Boolean;
    {Brush}
    _UseBrush:Boolean;
    Brush:PBrushRef;
    end;

{TToolSubClassEvent}
Type TToolSubClassEvent=Procedure(Var X:TPixelInfo);

{TOrientationInfo}
Type
    TOrientationInfo=Record
    //Options
    Invert:Boolean;
    Flip:Boolean;
    Mirror:Boolean;
    Rotate:Integer;
    //Options Enabled or Not
    CanInvert:Boolean;
    CanFlip:Boolean;
    CanMirror:Boolean;
    CanRotate:Boolean;
    end;

{TPenInfo}
Type
    TPenInfo=Record
    {Image}
    Image:TBitmap;
    {Size - Square W=H}
    Size:Integer;
    {Options}
    Options:TOrientationInfo;
    {Internal Only}
    FColor:Integer;
    BColor:Integer;
    end;

{TPixelManipulationMethod}
Const
     pmmcMax=99;
Type
    {TPixelManipulationMethod}
    TPixelManipulationMethod=Procedure(Var X:TPixelInfo);
    {TPixelManipulationMethodHandler}
    TPixelManipulationMethodHandler=Record
    Method:TPixelManipulationMethod;
    Name:String;
    CanDraw:Boolean;{Determines if suitable for Drawing}
    CanFilter:Boolean;{Determines if suitable for Filter Work}
    end;
    {TPixelManipulationMethods}
    TPixelManipulationMethods=Record
    Items:Array[0..pmmcMax] of TPixelManipulationMethodHandler;
    Count:Integer;
    end;

{TManipulationInfo}
Type
    PManipulationInfo=^TManipulationInfo;
    TManipulationInfo=Record
    //Image
    Image:TBitmap;
    //Rect
    Rect:TRect;
    NonZeroRect:Boolean;{ie X,Y->Width,Height instead of X,Y->Width-1,Height-1}
    Sizeable:Boolean;
    //ErrMsg
    ErrMsg:String;
    //Progress
    OnProgress:TProgressEvent;
    _UseProgress:Boolean;
    //Properties
    PMI:TPixelInfo;
    PMIProc:TPixelManipulationMethod;{Pointer to Procedure}
    end;

 //Info
 Function SafeInfo(Var X:TManipulationInfo):Boolean;
 //Rect
 Procedure OrderRect(Var X:TRect);
 Procedure FrcRangeRect(Var X:TRect;Bounds:TRect);
 Procedure SafeRect(Var X:TBitmap;Var Y:TRect;NonZero:Boolean);
 Function RectsEqual(X,Y:TRect):Boolean;
 Function ImageRect(X:TBitmap):TRect;
 Type
     TFocusRectInfo=Record
     Canvas:TCanvas;
     Area:TRect;
     Fine:Boolean;
     OutSide:Boolean;
     FColor:Integer;
     BColor:Integer;
     end;//end of type
 Procedure FocusRect(X:TFocusRectInfo);
 Function CopyImageTo(X,Y:TBitmap):Boolean;
 //CountImageColors: see MaxStackSize requires - refer to Function
 {TColors}
 Const
     csccMax=2097152;{8 Booleans per Byte}
 Type TColors=Array[0..csccMax] of Byte;
 {TBitArray}
 Type TBitArray=Array[0..7] of Boolean;
 Function ToByte(Var X:TBitArray):Byte;
 Procedure FromByte(X:Byte;Var Y:TBitArray);
 Function CountImageColors(Var X:TManipulationInfo):Integer;
 //Cls
 Function Cls(Var X:TManipulationInfo):Boolean;
 Function ClsColor(Var X:TManipulationInfo):Boolean;
 //Flip & Mirror
 Function Flip(Var X:TManipulationInfo):Boolean;
 Function Mirror(Var X:TManipulationInfo):Boolean;
 //Rotate +/-0,180,270
 Function Rotate90(Var X:TManipulationInfo;Left:Boolean):Boolean;
 Function Rotate(Var X:TManipulationInfo;Y:Integer):Boolean;
 //Invert
 Function Invert(Var X:TManipulationInfo):Boolean;
 Function InvertRGB(Var X:TManipulationInfo):Boolean;
 Procedure CustomiseCursor(X,Y:TCursor;Z:String);
 Function AlternateGrid8x8(X:TBitmap;F,B:Integer):Boolean;
 Function ProcessArea(Var X:TManipulationInfo):Boolean;
 Function OrientationInfoMatch(Var X,Y:TOrientationInfo):Boolean;
 Function Tile(Var X,Y:TBitmap):Boolean;
 Function _CopyRect(Dest:TCanvas;dRect:TRect;Source:TBitmap;sRect:TRect):Boolean;
 Function CopyPortion(Dest:TCanvas;dRect:TRect;Source:TBitmap;sRect:TRect):Boolean;
 Procedure SafeCoor(Var X,Y:Integer);
 Function ZoomMap(X,Y:Integer):Integer;
 Function ZoomUnMap(X,Y:Integer):Integer;
 Procedure Line(Sender:TObject;X:TRect;Y:TDrawPointEvent;Step:Integer);
 Function ScrnBits:Integer;
 Function ScrnPixelFormat:TPixelFormat;
 Function Stepable(cX,cY,dX,dY,Step:Integer):Boolean;
 //Pen Shapes
 Function OrientateImage(X:TBitmap;Var Y:TOrientationInfo):Boolean;
 Function psSafeInfo(Var X:TPenInfo):Boolean;
 Procedure psFinish(Var X:TPenInfo);{Internal Only}
 Procedure psCircle(Var X:TPenInfo);
 Procedure psSquare(Var X:TPenInfo);
 Procedure psBackSlash(Var X:TPenInfo);
 Procedure psForwardSlash(Var X:TPenInfo);
 Procedure psVerticalLine(Var X:TPenInfo);
 Procedure psThinVerticalLine(Var X:TPenInfo);
 Procedure psHorizontalLine(Var X:TPenInfo);
 Procedure psThinHorizontalLine(Var X:TPenInfo);
 Procedure psThinCross(Var X:TPenInfo);
 Procedure psOval(Var X:TPenInfo);
 Procedure psThinDiamond(Var X:TPenInfo);
 Procedure psDiamond(Var X:TPenInfo);

 //Tool Events
{TCursorInfo}
Type
    PCursorInfo=^TCursorInfo;
    TCursorInfo=Record
    X:Integer;
    Y:Integer;
    LastX:Integer;
    LastY:Integer;
    {Zoomed X,Y}
    ZoomX:Integer;
    ZoomY:Integer;
    LastZoomX:Integer;
    LastZoomY:Integer;
    {Sel}
    Sel:TRect;
    {Stepable - Internal Use Only}
    StepX:Integer;
    StepY:Integer;
    StepBy:Integer;
    end;

{TMouseInfo}
Type
    PMouseInfo=^TMouseInfo;
    TMouseInfo=Record
    Down:Boolean;
    Button:TMouseButton;
    Shift:TShiftState;
    CursorInfo:TCursorInfo;
    end;

{TColorInfo}
Type
    PColorInfo=^TColorInfo;
    TColorInfo=Record
    F:TColor24;
    B:TColor24;
    T:TColor24;
    end;

{THostEvents}
Type
    PHostEvents=^THostEvents;
    THostEvents=Record
    OnPixel:TDrawPointEvent;
    OnDrawPoint:TDrawPointEvent;
    RepaintRect:TRepaintRectEvent;
    end;

{TToolEventInfo}
Const
     {Actions}
     tvacOnMouseDown=0;
     tvacOnMouseMove=1;
     tvacOnMouseUp=2;
Type
    PToolEventInfo=^TToolEventInfo;
    TToolEventInfo=Record
    {Action}
    Action:Integer;
    {Mouse}
    MouseInfo:TMouseInfo;
    {Color}
    ColorInfo:TColorInfo;
    {Pen}
    PenRef:PPenRef;
    {Brush}
    BrushRef:PBrushRef;
    {ToolInfo}
    ToolInfo:TManipulationInfo;
    {Host Events}
    HostEvents:THostEvents;
    end;

{TToolEvent}
Type TToolEvent=Procedure(Var X:TToolEventInfo);

{TToolHandler}
Type
    PToolHandler=^TToolHandler;
    TToolHandler=Record
    {Name/Index of Tool}
    Style:String;
    Index:Integer;
    {EventInfo}
    EventInfo:TToolEventInfo;
    {Event}
    Event:TToolEvent;
    end;

 {Decision Routines}
 //# X.Scatter{0-100%}
 //General
 Function Posterize(X,Y:Integer):Integer;
 Function LumRGB(R,G,B:Integer):Integer;
 Function MaxRGB(R,G,B:Integer):Integer;
 Function MinRGB(R,G,B:Integer):Integer;
 Procedure SafeRGB(Var R,G,B:Integer);
 //PAL
 Procedure RGBtoYUV(Var RGB:TColor24;Var YUV:TIntTriplet);
 Procedure YUVtoRGB(Var YUV:TIntTriplet;Var RGB:TColor24);
 //NTSC
 Procedure RGBtoYIQ(Var RGB:TColor24;Var YIQ:TIntTriplet);
 Procedure YIQtoRGB(Var YIQ:TIntTriplet;Var RGB:TColor24);
 //CYM
 Procedure RGBtoCYM(Var RGB,CYM:TColor24);
 Procedure CYMtoRGB(Var CYM,RGB:TColor24);
 //Other
 Function GenerateSafeTC(X:TColor24):TColor24;
 Function ppdSafeColor(Var X:TPixelInfo;Var Y:TColor24):TColor24;
 Function ppdScatter(Var X:TPixelInfo):Boolean;
 {Color Adjustment Routines}
 //# X.Strength{0..100}/X.Scatter{0..100}
 Procedure ppBlur(Var X:TPixelInfo);
 Procedure ppRGBAdjust(Var X:TPixelInfo);
 Procedure ppBrightnessContrast(Var X:TPixelInfo);
 Procedure ppLuminanceChrominance(Var X:TPixelInfo);
 Procedure ppPosterize(Var X:TPixelInfo);
 Procedure ppSolarize(Var X:TPixelInfo);
 Procedure ppColorize(Var X:TPixelInfo);
 Procedure ppGreyScale(Var X:TPixelInfo);
 Procedure ppColor(Var X:TPixelInfo);
 Procedure ppEraser(Var X:TPixelInfo);
 Procedure ppReplace(Var X:TPixelInfo);
 Procedure ppReplaceShades(Var X:TPixelInfo);
 Procedure ppRandomColor(Var X:TPixelInfo);
 Procedure ppInvert(Var X:TPixelInfo);
 Procedure ppRemove(Var X:TPixelInfo);
 Procedure ppShades(Var X:TPixelInfo);
 Procedure ppMonoChrome(Var X:TPixelInfo);
 Procedure ppBlend(Var X:TPixelInfo);
 Procedure ppMerge(Var X:TPixelInfo);
 Procedure ppVerticalStripe(Var X:TPixelInfo);
 Procedure ppHorizontalStripe(Var X:TPixelInfo);
 Procedure ppLighten(Var X:TPixelInfo);
 Procedure ppDarken(Var X:TPixelInfo);
 Procedure ppPlasma(Var X:TPixelInfo);
 Procedure ppHotCold(Var X:TPixelInfo);

Implementation

//## SafeInfo ##
Function SafeInfo(Var X:TManipulationInfo):Boolean;
begin
try
{Error}
Result:=False;
//Image
If (X.Image=nil) then
   begin
   X.ErrMsg:='Undefined image handle.';
   exit;
   end;//end of if
//Rect
SafeRect(X.Image,X.Rect,X.NonZeroRect);
//OnProgress
X._UseProgress:=Assigned(X.OnProgress);
//Texture
//xxxxxxxX.PMI._UseTexture:=(X.PMI.Texture<>nil);
{Successful}
Result:=True;
except;X.ErrMsg:='Invalid image information.';end;
end;
//## OrderRect ##
Procedure OrderRect(Var X:TRect);
Var
   A:Integer;
begin
try
//X
If (X.Left>X.Right) then
   begin
   A:=X.Left;
   X.Left:=X.Right;
   X.Right:=A;
   end;//end of if
//Y
If (X.Top>X.Bottom) then
   begin
   A:=X.Top;
   X.Top:=X.Bottom;
   X.Bottom:=A;
   end;//end of if
except;end;
end;
//## FrcRangeRect ##
Procedure FrcRangeRect(Var X:TRect;Bounds:TRect);
begin
try
{Order "Bounds"}
OrderRect(Bounds);
{Process "X"}
X.Left:=FrcRange(X.Left,Bounds.Left,Bounds.Right);
X.Right:=FrcRange(X.Right,Bounds.Left,Bounds.Right);
X.Top:=FrcRange(X.Top,Bounds.Top,Bounds.Bottom);
X.Bottom:=FrcRange(X.Bottom,Bounds.Top,Bounds.Bottom);
except;end;
end;
//## SafeRect ##
Procedure SafeRect(Var X:TBitmap;Var Y:TRect;NonZero:Boolean);
Var
   W,H:Integer;
begin
try
If (X=nil) then exit;
W:=X.Width;
H:=X.Height;
If Not NonZero then
   begin
   W:=W-1;
   H:=H-1;
   end;//end of if
Y.Left:=FrcRange(Y.Left,0,W);
Y.Right:=FrcRange(Y.Right,0,W);
Y.Top:=FrcRange(Y.Top,0,H);
Y.Bottom:=FrcRange(Y.Bottom,0,H);
{OrderRect}
OrderRect(Y);
except;end;
end;
//## RectsEqual ##
Function RectsEqual(X,Y:TRect):Boolean;
begin
try
{Order}
OrderRect(X);
OrderRect(Y);
{Compare}
Result:=(X.Left=Y.Left) and (X.Top=Y.Top) and (X.Right=Y.Right) and (X.Bottom=Y.Bottom);
except;end;
end;
//## FocusRect ##
Procedure FocusRect(X:TFocusRectInfo);
begin
try
If (X.Canvas=nil) then exit;
{Invalid Area}
If (X.Area.Left=X.Area.Right) and (X.Area.Top=X.Area.Bottom) then exit;
{Outside}
If X.OutSide then
   begin
   X.Area.Left:=X.Area.Left-1;
   X.Area.Top:=X.Area.Top-1;
   X.Area.Right:=X.Area.Right+1;
   X.Area.Bottom:=X.Area.Bottom+1;
   end;//end of if
{Focus,OutLine Rects}
Case X.Fine of
True:X.Canvas.DrawFocusRect(X.Area);
False:begin
    X.Canvas.Brush.Color:=X.BColor;
    X.Canvas.Pen.Color:=X.FColor;
    X.Canvas.Pen.Style:=psDot;
    X.Canvas.Polyline([Point(X.Area.Left,X.Area.Top),Point(X.Area.Right-1,X.Area.Top),Point(X.Area.Right-1,X.Area.Bottom-1),Point(X.Area.Left,X.Area.Bottom-1),Point(X.Area.Left,X.Area.Top)]);
    X.Canvas.Pen.Style:=psSolid;
    end;//end of begin
end;//end of case
except;end;
end;
//## ImageRect ##
Function ImageRect(X:TBitmap):TRect;
begin
try
Case (X=nil) of
True:Result:=Rect(0,0,-1,-1);
False:Result:=Rect(0,0,X.Width,X.Height);
end;//end of case
except;end;
end;
//## CopyImageTo ##
Function CopyImageTo(X,Y:TBitmap):Boolean;
begin
try
{Error}
Result:=False;
{Size Y}
Y.PixelFormat:=X.PixelFormat;
Y.Width:=X.Width;
Y.Height:=X.Height;
{Copy}
Y.Canvas.CopyRect(Rect(0,0,Y.Width,Y.Height),X.Canvas,Rect(0,0,Y.Width,Y.Height));
{Successful}
Result:=True;
except;end;
end;
//## Cls ##
Function Cls(Var X:TManipulationInfo):Boolean;
begin
try
X.PMI.A.R:=255;
X.PMI.A.G:=255;
X.PMI.A.B:=255;
Result:=ClsColor(X);
except;end;
end;
//## ClsColor ##
Function ClsColor(Var X:TManipulationInfo):Boolean;
begin
try
{Error}
Result:=False;
If Not SafeInfo(X) then exit;
X.Image.Canvas.Brush.Color:=RGB(X.PMI.A.R,X.PMI.A.G,X.pmi.A.B);
X.Image.Canvas.FillRect(Rect(X.Rect.Left,X.Rect.Top,X.Rect.Right,X.Rect.Bottom));
{Successful}
Result:=True;
except;X.ErrMsg:=gecOutOfMemory;end;
end;
//## Flip ##
Function Flip(Var X:TManipulationInfo):Boolean;
Var
   dRect,sRect:TRect;
begin
try
{Error}
Result:=False;
If Not SafeInfo(X) then exit;
{Flip Image}
dRect:=X.Rect;
sRect:=Rect(X.Rect.Left,X.Rect.Bottom-1,X.Rect.Right,X.Rect.Top-1);
X.Image.Canvas.CopyRect(dRect,X.Image.Canvas,sRect);
{Successful}
Result:=True;
except;X.ErrMsg:='Out of memory.';end;
end;
//## Mirror ##
Function Mirror(Var X:TManipulationInfo):Boolean;
Var
   sRect,dRect:TRect;
begin
try
{Error}
Result:=False;
If Not SafeInfo(X) then exit;
{Mirror Image}
dRect:=X.Rect;
sRect:=Rect(X.Rect.Right-1,X.Rect.Top,X.Rect.Left-1,X.Rect.Bottom);
X.Image.Canvas.CopyRect(dRect,X.Image.Canvas,sRect);
{Successful}
Result:=True;
except;X.ErrMsg:='Out of memory.';end;
end;
//## Rotate90 ##
Function Rotate90(Var X:TManipulationInfo;Left:Boolean):Boolean;
Var
   xRow:PRGBColorRow;
   aRows:TRGBColorRows;
   A:TBitmap;
   dX,dY,MaxX,MaxY,rX,rY:Integer;
begin{Rotates entire Image only, ignores any sections}
try
{Error}
Result:=False;
A:=nil;
If Not SafeInfo(X) then exit;
{Copy Original}
A:=TBitmap.Create;
A.PixelFormat:=pf24bit;
CopyImageTo(X.Image,A);
{Rotate Dimensions by 90}
X.Image.Width:=A.Height;
X.Image.Height:=A.Width;
{Prepare Cache}
For rY:=0 to (A.Height-1) Do aRows[rY]:=A.ScanLine[rY];
{Rotate Pixels by 90}
MaxX:=X.Image.Width-1;
MaxY:=X.Image.Height-1;
For rY:=0 to MaxY Do
begin
xRow:=X.Image.Scanline[rY];
Case Left of
False:For rX:=0 to MaxX Do xRow[rX]:=aRows[MaxX-rX][rY];
True:For rX:=0 to MaxX Do xRow[rX]:=aRows[rX][MaxY-rY];
end;//end of case
end;//end of loop
{Successful}
Result:=True;
except;X.ErrMsg:=gecOutOfMemory;end;
try;A.Free;except;end;
end;
//## Rotate ##
Function Rotate(Var X:TManipulationInfo;Y:Integer):Boolean;
begin
try
{Error}
Result:=False;
If Not SafeInfo(X) then exit;
{Rotate Image:
              +/- 0,90,180,270 Degrees
              + = Right - Clockwise
              - = Left - AntiClockwise}
Case Y of
-359..-270,1..90:Result:=Rotate90(X,False);
-269..-180,91..180:If Flip(X) then Result:=Mirror(X);
-174..-90,181..270:Result:=Rotate90(X,True);
-89..0,-360,360:Result:=True;{Null 0 or 360}
end;//end of case
except;end;
end;
//## Invert ##
Function Invert(Var X:TManipulationInfo):Boolean;
begin
try
X.PMI.aR:=255;
X.PMI.aG:=255;
X.PMI.aB:=255;
Result:=InvertRGB(X);
except;end;
end;
//## InvertRGB ##
Function InvertRGB(Var X:TManipulationInfo):Boolean;
Var
   Row:PRGBColorRow;
   A,MinX,MinY,MaxX,MaxY,rX,rY:Integer;
   Z:TColor24;
   B:TPixelInfo;
begin
try
{Error}
Result:=False;
If Not SafeInfo(X) then exit;
B:=X.PMI;
if (B.aR=0) and (B.aG=0) and (B.aB=0) then
   begin
   Result:=True;
   exit;
   end;//end of if
{24bit only}
X.Image.PixelFormat:=pf24bit;
{Draw Y -> X}
MinX:=X.Rect.Left;
MaxX:=X.Rect.Right-1;
MinY:=X.Rect.Top;
MaxY:=X.Rect.Bottom-1;
For rY:=MinY to MaxY Do
begin
Row:=X.Image.ScanLine[rY];
 For rX:=MinX to MaxX Do
 begin
 Z:=Row[rX];
 If (B.aR<>0) then Z.R:=255-Z.R;
 If (B.aG<>0) then Z.G:=255-Z.G;
 If (B.aB<>0) then Z.B:=255-Z.B;
 Row[rX]:=Z;
 end;//End of INNER LOOP
end;//End of OUTER LOOP
{Successful}
Result:=True;
except;X.ErrMsg:=gecOutOfMemory;end;
end;
//## ProcessArea ##
Function ProcessArea(Var X:TManipulationInfo):Boolean;
Var
   Row:PRGBColorRow;
   A,MinX,MinY,MaxX,MaxY,rX,rY:Integer;
   B:TPixelInfo;
   C:TPixelManipulationMethod;
   D:PBrushRef;
   Z:TColor24;
begin
try
{Error}
Result:=False;
If Not SafeInfo(X) then exit;
{PMITexture}
D:=X.PMI.Brush;
{PMIProc}
C:=X.PMIProc;
B:=X.PMI;
B.SafeTC:=GenerateSafeTC(B.TC);
{Indicate Temp Variables are not set}
B.atSet:=False;
{24bit only}
X.Image.PixelFormat:=pf24bit;
{Draw Y -> X}
MinX:=X.Rect.Left;
MaxX:=X.Rect.Right-1;
MinY:=X.Rect.Top;
MaxY:=X.Rect.Bottom-1;
{Aquire Rows}
For rY:=0 to (X.Image.Height-1) Do B.Rows[rY]:=X.Image.Scanline[rY];
B.zW:=X.Image.Width-1;
B.zH:=X.Image.Height-1;
B.L:=0;{Default if no brush used}
{Process}
For rY:=MinY to MaxY Do
begin
{Y}
B.Y:=rY;
{Row}
Row:=X.PMI.Rows[rY];
 Case X.PMI._UseBrush of
 False:begin
      For rX:=MinX to MaxX Do
      begin
      {X}
      B.X:=rX;
      {Pixel Processor}
      C(B);
      end;//end of loop
      end;//end of begin
 True:begin
      For rX:=MinX to MaxX Do
      begin
      {Texture Processor}
      B.L:=D.Pixels[D.MapY[Word(rY)],D.MapX[Word(rX)]];
      If (B.L<255) then
         begin
         {X}
         B.X:=rX;
         {Pixel Processor}
         C(B);
         end;//end of if
      end;//end of loop
      end;//end of begin
 end;//end of case
end;//end of loop
{Successful}
Result:=True;
except;X.ErrMsg:='Out of memory.';end;
end;

//################# PixelManipulationMethods ###################################
//## psSafeInfo ##
Function psSafeInfo(Var X:TPenInfo):Boolean;
Var
   A:Integer;
begin
try
{Error}
Result:=False;
//Image
If (X.Image=nil) then exit;
//Size
If (X.Size<1) then X.Size:=1;
//Colors
X.FColor:=clBlack;
X.BColor:=clWhite;
//Invert
If X.Options.Invert then
   begin
   A:=X.FColor;
   X.FColor:=X.BColor;
   X.BColor:=A;
   end;//end of if
{Size}
X.Image.Width:=X.Size;
X.Image.Height:=X.Size;
{Cls}
X.Image.Canvas.Brush.Color:=X.BColor;
X.Image.Canvas.FillRect(Rect(0,0,X.Image.Width,X.Image.Height));
{Setup}
X.Image.Canvas.Pen.Color:=X.FColor;
X.Image.Canvas.Brush.Color:=X.FColor;
{Successful}
Result:=True;
except;end;
end;
//## OrientationInfoMatch ##
Function OrientationInfoMatch(Var X,Y:TOrientationInfo):Boolean;
begin
try;Result:=(X.CanInvert=Y.CanInvert) and (X.CanFlip=Y.CanFlip) and (X.CanMirror=Y.CanMirror) and (X.CanRotate=Y.CanRotate) and (X.Invert=Y.Invert) and (X.Flip=Y.Flip) and (X.Mirror=Y.Mirror) and (X.Rotate=Y.Rotate);except;end;
end;
//## OrientateImage ##
Function OrientateImage(X:TBitmap;Var Y:TOrientationInfo):Boolean;
Label
     SkipEnd;
Var
   A:TManipulationInfo;
begin{Flip/Mirror/Invert/Rotate}
try
{Error}
Result:=False;
If (X=nil) then Goto SkipEnd;
//Read
A.Image:=X;
A.Rect:=ImageRect(A.Image);
A.NonZeroRect:=True;
A.PMI.A.R:=255;
A.PMI.A.G:=255;
A.PMI.A.B:=255;
//Flip
If Y.CanFlip and Y.Flip then If Not Flip(A) then Goto SkipEnd;
//Mirror
If Y.CanMirror and Y.Mirror then If Not Mirror(A) then Goto SkipEnd;
//Invert
If Y.CanInvert and Y.Invert then If Not Invert(A) then Goto SkipEnd;
//Rotate - LAST as A.Rect alters at this point!
If Y.CanRotate and (Y.Rotate<>0) then If Not Rotate(A,Y.Rotate) then Goto SkipEnd;
{Successful}
Result:=True;
SkipEnd:
except;end;
end;
//## psFinish ##
Procedure psFinish(Var X:TPenInfo);
begin
try;OrientateImage(X.Image,X.Options);except;end;
end;
//## psCircle ##
Procedure psCircle(Var X:TPenInfo);
begin
try
If Not psSafeInfo(X) then exit;
{Shape}
X.Image.Canvas.Ellipse(0,0,X.Image.Width,X.Image.Height);
{Finish}
psFinish(X);
except;end;
end;
//## psSquare ##
Procedure psSquare(Var X:TPenInfo);
begin
try
If Not psSafeInfo(X) then exit;
{Shape}
X.Image.Canvas.FillRect(Rect(0,0,X.Image.Width,X.Image.Height));
{Finish}
psFinish(X);
except;end;
end;
//## psBackSlash ##
Procedure psBackSlash(Var X:TPenInfo);
Var
   P,MaxP:Integer;
begin
try
If Not psSafeInfo(X) then exit;
{Shape}
MaxP:=X.Image.Width Div 4;
For P:=0 to MaxP Do
begin
X.Image.Canvas.MoveTo(P,0);
X.Image.Canvas.LineTo(X.Image.Width-MaxP+P,X.Image.Height);
end;//end of loop
{Finish}
psFinish(X);
except;end;
end;
//## psForwardSlash ##
Procedure psForwardSlash(Var X:TPenInfo);
Var
   P,MaxP:Integer;
begin
try
If Not psSafeInfo(X) then exit;
{Shape}
MaxP:=X.Image.Width Div 4;
For P:=0 to MaxP Do
begin
X.Image.Canvas.MoveTo(X.Image.Width-MaxP+P,0);
X.Image.Canvas.LineTo(P,X.Image.Height);
end;//end of loop
{Finish}
psFinish(X);
except;end;
end;
//## psVerticalLine ##
Procedure psVerticalLine(Var X:TPenInfo);
Var
   xMiddle,xBy:Integer;
begin
try
If Not psSafeInfo(X) then exit;
{Shape}
xBy:=(X.Image.Width Div 5);
xMiddle:=(X.Image.Width Div 2);
X.Image.Canvas.FillRect(Rect(xMiddle-xBy,0,xMiddle+xBy,X.Image.Height));
{Finish}
psFinish(X);
except;end;
end;
//## psThinVerticalLine ##
Procedure psThinVerticalLine(Var X:TPenInfo);
Var
   xMiddle:Integer;
begin
try
If Not psSafeInfo(X) then exit;
{Shape}
xMiddle:=(X.Image.Width Div 2);
X.Image.Canvas.MoveTo(xMiddle,0);
X.Image.Canvas.LineTo(xMiddle,X.Image.Height-1);
{Finish}
psFinish(X);
except;end;
end;
//## psHorizontalLine ##
Procedure psHorizontalLine(Var X:TPenInfo);
Var
   xMiddle,xBy:Integer;
begin
try
If Not psSafeInfo(X) then exit;
{Shape}
xBy:=(X.Image.Height Div 5);
xMiddle:=(X.Image.Height Div 2);
X.Image.Canvas.FillRect(Rect(0,xMiddle-xBy,X.Image.Width,xMiddle+xBy));
{Finish}
psFinish(X);
except;end;
end;
//## psThinHorizontalLine ##
Procedure psThinHorizontalLine(Var X:TPenInfo);
Var
   xMiddle:Integer;
begin
try
If Not psSafeInfo(X) then exit;
{Shape}
xMiddle:=(X.Image.Height Div 2);
X.Image.Canvas.MoveTo(0,xMiddle);
X.Image.Canvas.LineTo(X.Image.Width-1,xMiddle);
{Finish}
psFinish(X);
except;end;
end;
//## psThinCross ##
Procedure psThinCross(Var X:TPenInfo);
Var
   xMiddle,yMiddle:Integer;
begin
try
If Not psSafeInfo(X) then exit;
{Shape}
xMiddle:=(X.Image.Width Div 2);
yMiddle:=(X.Image.Height Div 2);
//Horz
X.Image.Canvas.MoveTo(0,yMiddle);
X.Image.Canvas.LineTo(X.Image.Width-1,yMiddle);
//Vert
X.Image.Canvas.MoveTo(xMiddle,0);
X.Image.Canvas.LineTo(xMiddle,X.Image.Height-1);
{Finish}
psFinish(X);
except;end;
end;
//## psOval ##
Procedure psOval(Var X:TPenInfo);
Var
   xBy:Integer;
begin
try
If Not psSafeInfo(X) then exit;
{Shape}
xBy:=X.Image.Width Div 4;
X.Image.Canvas.Ellipse(xBy,0,X.Image.Width-xBy,X.Image.Height);
{Finish}
psFinish(X);
except;end;
end;
//## psDiamond ##
Procedure psDiamond(Var X:TPenInfo);
Var
   W,H,xH,yH:Integer;
begin
try
If Not psSafeInfo(X) then exit;
{Data}
W:=X.Image.Width;
H:=X.Image.Height;
//W
If (((W Div 2)*2)=W) and (W>1) then W:=W-1;
W:=W-1;
//H
If (((H Div 2)*2)=H) and (H>1) then H:=H-1;
H:=H-1;
//xH,yH
xH:=W Div 2;
yH:=H Div 2;
{Shape}
X.Image.Canvas.Polygon([Point(xH,0),Point(0,yH),Point(xH,H),Point(W,yH)]);
{Finish}
psFinish(X);
except;end;
end;
//## psThinDiamond ##
Procedure psThinDiamond(Var X:TPenInfo);
Var
   xBy,W,H,xH,yH:Integer;
begin
try
If Not psSafeInfo(X) then exit;
{Data}
W:=X.Image.Width;
H:=X.Image.Height;
//W
If (((W Div 2)*2)=W) and (W>1) then W:=W-1;
W:=W-1;
//H
If (((H Div 2)*2)=H) and (H>1) then H:=H-1;
H:=H-1;
//xH,yH
xH:=W Div 2;
yH:=H Div 2;
//xBy
xBy:=(W Div 4)-1;
{Shape}
X.Image.Canvas.Polygon([Point(xH,0),Point(xH-xBy,yH),Point(xH,H),Point(xH+xBy,yH)]);
{Finish}
psFinish(X);
except;end;
end;
//## ZoomMap ##
Function ZoomMap(X,Y:Integer):Integer;
begin
try
Case Y of
2..64:Result:=X*Y;
-64..-2:Result:=X Div (-Y);
else{-1..1,<-64,>64}
Result:=X;
end;//end of case
except;end;
end;
//## ZoomUnMap ##
Function ZoomUnMap(X,Y:Integer):Integer;
begin
try
Case Y of
2..64:Result:=X Div Y;
-64..-2:Result:=X*(-Y);
else{-1..1,<-64,>64}
Result:=X;
end;//end of case
except;end;
end;
//## SafeCoor ##
Procedure SafeCoor(Var X,Y:Integer);
Var
   Z:Integer;
begin
try
Z:=High(Word);
If (X<0) then X:=0;
If (Y<0) then Y:=0;
If (X>Z) then X:=Z;
If (Y>Z) then Y:=Z;
except;end;
end;
//## _CopyRect ##
Function _CopyRect(Dest:TCanvas;dRect:TRect;Source:TBitmap;sRect:TRect):Boolean;
Var
   B,A:TBitmap;
begin
try
{Error}
Result:=False;
{A}
A:=nil;
B:=nil;
A:=TBitmap.Create;
B:=TBitmap.Create;
A.PixelFormat:=Source.PixelFormat;
B.PixelFormat:=Source.PixelFormat;
//#1
A.Width:=(sRect.Right-sRect.Left)+1;
A.Height:=(sRect.Bottom-sRect.Top)+1;
A.Canvas.CopyRect(Rect(0,0,A.Width,A.Height),Source.Canvas,sRect);
//#2
B.Width:=(dRect.Right-dRect.Left)+1;
B.Height:=(dRect.Bottom-dRect.Top)+1;
B.Canvas.StretchDraw(Rect(0,0,B.Width,B.Height),A);
//#2
Dest.Draw(dRect.Left,dRect.Top,B);
{Successful}
Result:=True;
except;end;
try;A.Free;B.Free;except;end;
end;
//## CopyPortion ##
Function CopyPortion(Dest:TCanvas;dRect:TRect;Source:TBitmap;sRect:TRect):Boolean;
Var
   A:TBitmap;
   osRect:TRect;
   MinX,MinY,MaxX,MaxY,dX,sX,sY,dY,P,pX,rX,pY,rY:Integer;
   sRow,dRow:PRGBColorRow;
   rrL,rrT,rrR,rrB,rrX,rrY:Extended;
   xM,yM:Integer;
begin
try
{SafeRect(Source,sRect);
Result:=True;
Dest.CopyRect(dRect,Source.Canvas,sRect);//xxxxxxx
exit;
{}
//xxxxxxxxxxxxxxxxx
{Error}
Result:=False;
A:=nil;
SafeRect(Source,sRect,False);
{A}
A:=TBitmap.Create;
A.PixelFormat:=pf24bit;
A.Width:=sRect.Right-sRect.Left+1;
A.Height:=sRect.Bottom-sRect.Top+1;
For rY:=sRect.Top to sRect.Bottom Do
begin
sRow:=Source.Scanline[rY];
dRow:=A.Scanline[rY-sRect.Top];
 For rX:=sRect.Left to sRect.Right Do
 begin
 dRow[rX-sRect.Left]:=sRow[rX];
 end;//end of loop
end;//end of loop

{A -> Dest}
//Dest.CopyRect(dRect,A.Canvas,Rect(0,0,A.Width-1,A.Height-1));
xM:=(dRect.Right-dRect.Left) div (sRect.Right-sRect.Left) Div 2;
yM:=(dRect.Bottom-dRect.Top) div (sRect.Bottom-sRect.Top) Div 2;
//xxxxxxxshowmessage(inttostr(xM));

dRect.Left:=dRect.Left-xM;
dRect.Top:=dRect.Top-yM;

dRect.Right:=dRect.Right+xM;
dRect.Bottom:=dRect.Bottom+yM;
//xxxxxxxxxxxxxxxxxxxxx

Dest.StretchDraw(dRect,A);
{Successful}
Result:=True;
except;showmessage('err>>'+inttostr(rY)+','+inttostr(rX));end;
try;A.Free;except;end;
end;
//## Tile ##
Function Tile(Var X,Y:TBitmap):Boolean;
Var
   P,MaxP:Integer;
   sRect,dRect:TRect;
begin{X=Patterm, Y=destination image}
try
{Error}
Result:=False;
If (X=nil) or (Y=nil) then exit;
{0,0}
Y.Canvas.Draw(0,0,X);
{1 Row}
MaxP:=(Y.Width Div X.Width)+1;
For P:=1 to MaxP Do Y.Canvas.Draw(P*X.Width,0,X);
{Columns using 1st Row}
MaxP:=(Y.Height Div X.Height)+1;
sRect:=Rect(0,0,Y.Width,X.Height);
For P:=1 to MaxP Do
begin//xxxxxxxxxx //needs work!
Y.Canvas.Draw(0,P*X.Height,Y);
end;//end of loop
{Successful}
Result:=True;
except;end;
end;
//## Line ##
Procedure Line(Sender:TObject;X:TRect;Y:TDrawPointEvent;Step:Integer);
Label
     ReDo2,ReDo;
Var
   xP,yP,C,MaxC,dX,dY:Integer;
   opp,adj,angle:Real;
begin
try
If Not Assigned(Y) then exit;
{Incremental Draw, Default=1}
If (Step<1) then Step:=1;
{Process}
adj:=X.Bottom-X.Top;
opp:=X.Right-X.Left;
xP:=1;
yP:=1;
if (opp<0) then
   begin
   opp:=-opp;
   xP:=-xP;
   end;//end of if
{Setup C}
C:=0;
{Special Case "adj=0"}
if (adj=0) then
   begin
   MaxC:=Round(opp);
   ReDo2:
   dX:=X.Left+xP*C;
   dY:=X.Top;
   Y(Sender,dX,dY);
   {Increment Position}
   If (C<MaxC) then
      begin
      C:=C+Step;
      If (C<=MaxC) then Goto ReDo2;
      end;//end of if
   exit;
   end;//end of if
if (adj<0) then
   begin
   adj:=-adj;
   yP:=-yP;
   end;//end of if
angle:=ArcTan(opp/adj);
MaxC:=Round(Sqrt(opp*opp+adj*adj));
ReDo:
{Calculate Coordinates}
dX:=X.Left+xP*Round(Sin(angle)*C);
dY:=X.Top+yP*Round(Cos(angle)*C);
{Call Host}
Y(Sender,dX,dY);
{Increment Position}
If (C<MaxC) then
   begin
   C:=C+Step;
   If (C<=MaxC) then Goto ReDo;
   end;//end of if
except;end;
end;

//################# Pixel Processors ###########################################
//## Posterize ##
Function Posterize(X,Y:Integer):Integer;
Var
   Sec,Size:Integer;
begin
try
{Default}
Result:=0;
{Ignore}
If (Y<1) then exit;
{X}
X:=X+1;
{Size & Sec}
Size:=256 Div Y;
Sec:=256 Div (Y+1);
{Ignore}
If (Size=0) or (Sec=0) then exit;
{Process}
X:=((X Div Sec)*Size)-1;
{Enforce Range}
If (X<0) then X:=0 else if (X>255) then X:=255;
{Return Result}
Result:=X;
except;end;
end;
//## LumRGB ##
Function LumRGB(R,G,B:Integer):Integer;
begin
try
Result:=Round(0.257*R+0.504*G+0.098*B)+16;
if (Result<0) then Result:=0 else if (Result>255) then Result:=255;
except;end;
end;
//## MaxRGB ##
Function MaxRGB(R,G,B:Integer):Integer;
begin
try
Result:=R;
If (G>Result) then Result:=G;
If (B>Result) then Result:=B;
except;end;
end;
//## MinRGB ##
Function MinRGB(R,G,B:Integer):Integer;
begin
try
Result:=R;
If (G<Result) then Result:=G;
If (B<Result) then Result:=B;
except;end;
end;
//## SafeRGB ##
Procedure SafeRGB(Var R,G,B:Integer);
begin
try
if (R<0) then R:=0 else if (R>255) then R:=255;
if (G<0) then G:=0 else if (G>255) then G:=255;
if (B<0) then B:=0 else if (B>255) then B:=255;
except;end;
end;
//## HSVtoRGB {Hue/Saturation/Luminance} ##
Procedure HSVtoRGB(Var HSV:TIntTriplet;Var RGB:TColor24);
Label
     SkipOne;
Var
   H,S,V:Double;
   RR,GG,BB:Double;
   R,G,B:Integer;
   f,ss,hh,p,q,t:Double;
   i:Integer;
begin
try
{Split HSV}
hh:=HSV[0];{0..359 degrees}
ss:=HSV[1]/100;{0.100%}
V:=HSV[2]/255;{0..255}
If (HSV[1]>78) then V:=V+((HSV[1]-78)/100);
{HSV -> RGB}
//Grey
If (ss=0) then
   begin
   RR:=V;
   GG:=V;
   BB:=V;
   Goto SkipOne;
   end;//end of if
//Color
hh:=hh/60;
i:=Floor(hh);
f:=hh-i;
p:=v*(1-ss);
q:=v*(1-ss*f);
t:=v*(1-ss*(1-f));
{Decide}
Case i of
0:begin;RR:=v;GG:=t;BB:=p;end;
1:begin;RR:=q;GG:=v;BB:=p;end;
2:begin;RR:=p;GG:=v;BB:=t;end;
3:begin;RR:=p;GG:=q;BB:=v;end;
4:begin;RR:=t;GG:=p;BB:=v;end;
else
 begin;RR:=v;GG:=p;BB:=q;end;
end;//end of case
{Double -> Integer}
R:=Round(RR*255);
G:=Round(GG*255);
B:=Round(BB*255);
SkipOne:
{Enforce RGB Range}
SafeRGB(R,G,B);
{Assign}
RGB.R:=Byte(R);
RGB.G:=Byte(G);
RGB.B:=Byte(B);
except;end;
end;
//## RGBtoYUV {PAL} ##
Procedure RGBtoYUV(Var RGB:TColor24;Var YUV:TIntTriplet);
Var
   R,G,B:Double;
begin
try
{Split RGB}
R:=RGB.R;
G:=RGB.G;
B:=RGB.B;
{RGB -> YUV}
YUV[0]:=Round(0.299*R+0.587*G+0.114*B);
YUV[1]:=Round(-0.147*R-0.289*G+0.437*B);
YUV[2]:=Round(0.615*R-0.515*G-0.100*B);
except;end;
end;
//## YUVtoRGB {PAL} ##
Procedure YUVtoRGB(Var YUV:TIntTriplet;Var RGB:TColor24);
Var
   Y,U,V:Double;
   R,G,B:Integer;
begin
try
{Split YUV}
Y:=YUV[0];
U:=YUV[1];
V:=YUV[2];
{YUV -> RGB}
R:=Round(Y+1.403*V);
G:=Round(Y-0.344*U-0.714*V);
B:=Round(Y+1.773*U);
{Enforce RGB Range}
SafeRGB(R,G,B);
{Assign}
RGB.R:=Byte(R);
RGB.G:=Byte(G);
RGB.B:=Byte(B);
except;end;
end;
//## RGBtoYIQ {NTSC} ##
Procedure RGBtoYIQ(Var RGB:TColor24;Var YIQ:TIntTriplet);
Var
   R,G,B:Double;
begin
try
{Split RGB}
R:=RGB.R;
G:=RGB.G;
B:=RGB.B;
{RGB -> YIQ}
YIQ[0]:=Round(0.299*R+0.587*G+0.114*B);
YIQ[1]:=Round(0.596*R-0.274*G-0.322*B);
YIQ[2]:=Round(0.211*R-0.523*G-0.312*B);
except;end;
end;
//## YIQtoRGB {NTSC} ##
Procedure YIQtoRGB(Var YIQ:TIntTriplet;Var RGB:TColor24);
Var
   Y,I,Q:Double;
   R,G,B:Integer;
begin
try
{Split YIQ}
Y:=YIQ[0];
I:=YIQ[1];
Q:=YIQ[2];
{YIQ -> RGB}
R:=Round(Y+0.956*I+0.621*Q);
G:=Round(Y-0.272*I-0.647*I);
B:=Round(Y-1.105*I+1.702*Q);
{Enforce RGB Range}
SafeRGB(R,G,B);
{Assign}
RGB.R:=Byte(R);
RGB.G:=Byte(G);
RGB.B:=Byte(B);
except;end;
end;
//## RGBtoCYM {Cyan, Yellow, Magenta} ##
Procedure RGBtoCYM(Var RGB,CYM:TColor24);
begin
try
//C
CYM.R:=Byte(255-Integer(RGB.R));
//Y
CYM.G:=Byte(255-Integer(RGB.B));
//M
CYM.B:=Byte(255-Integer(RGB.G));
except;end;
end;
//## CYMtoRGB {Cyan, Yellow, Magenta} ##
Procedure CYMtoRGB(Var CYM,RGB:TColor24);
begin
try
//R
RGB.R:=Byte(255-Integer(CYM.R));{C}
//G
RGB.G:=Byte(255-Integer(RGB.B));{M}
//B
RGB.B:=Byte(255-Integer(RGB.G));{Y}
except;end;
end;
//## GenerateSafeTC ##
Function GenerateSafeTC(X:TColor24):TColor24;
Const
     by=9;
Var
   R,G,B:Byte;
begin
try{Input is transparentColor, output is SafeTransparentColor}
R:=X.R;
G:=X.G;
B:=X.B;
If (R>=by) then R:=R-by else R:=R+by;
If (G>=by) then G:=G-by else G:=G+by;
If (B>=by) then B:=B-by else B:=B+by;
{Return Result}
Result.R:=R;
Result.G:=G;
Result.B:=B;
except;end;
end;
//## ppdSafeColor ##
Function ppdSafeColor(Var X:TPixelInfo;Var Y:TColor24):TColor24;
Var
   Z:TColor24;
   L,Lb,R,G,B:Integer;
begin
try
{Texturize Color}
Z:=X.Rows[X.Y][X.X];
{L & Lb}
L:=X.L;
Lb:=255-L;
{Merge Z & Y using L/Lb}
R:=(Z.R*L+Y.R*Lb) Div 255;
G:=(Z.G*L+Y.G*Lb) Div 255;
B:=(Z.B*L+Y.B*Lb) Div 255;
{Enforce Range}
SafeRGB(R,G,B);
{Prepare Result}
Result.R:=R;
Result.G:=G;
Result.B:=B;
{Check Color}
If X.Transparent and RGBEqual(X.TC,Result) then Result:=X.SafeTC;
except;end;
end;
//## ppdScatter ##
Function ppdScatter(Var X:TPixelInfo):Boolean;
begin
try
{Transparent Pixel}
If X.Transparent then
   begin
   If RGBEqual(X.Rows[X.Y][X.X],X.TC) then
      begin
      Result:=False;
      exit;
      end;//end of if
   end;//end of if
{Scatter}
Case (X.Scatter=0) of
True:Result:=True;
False:Result:=(Random(27-(X.Scatter Div 4))=0);
end;//end of case
except;end;
end;
//## ppBlur ##
Procedure ppBlur(Var X:TPixelInfo);
Var
   rX,rY,P,D,R,G,B:Integer;
   Z:TColor24;
   NotTransparent:Boolean;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{NotTransparent}
NotTransparent:=Not X.Transparent;
{Get Color}
Z:=X.Rows[X.Y][X.X];
{Current Pixel Color}
D:=(101-X.Strength) Div 2;{Med. Strengths}
R:=Integer(Z.R)*D;
G:=Integer(Z.G)*D;
B:=Integer(Z.B)*D;
{X-1}
If ((X.X-1)>=0) then
   begin
   Z:=X.Rows[X.Y][X.X-1];
   If NotTransparent or (Not RGBEqual(Z,X.TC)) then
      begin
      R:=R+Integer(Z.R);
      G:=G+Integer(Z.G);
      B:=B+Integer(Z.B);
      d:=d+1;
      end;//end of if
   end;//end of if
{X+1}
If ((X.X+1)<=X.zW) then
   begin
   Z:=X.Rows[X.Y][X.X+1];
   If NotTransparent or (Not RGBEqual(Z,X.TC)) then
      begin
      R:=R+Integer(Z.R);
      G:=G+Integer(Z.G);
      B:=B+Integer(Z.B);
      d:=d+1;
      end;//end of if
   end;//end of if
{Y-1}
If ((X.Y-1)>=0) then
   begin
   Z:=X.Rows[X.Y-1][X.X];
   If NotTransparent or (Not RGBEqual(Z,X.TC)) then
      begin
      R:=R+Integer(Z.R);
      G:=G+Integer(Z.G);
      B:=B+Integer(Z.B);
      d:=d+1;
      end;//end of if
   end;//end of if
{Y+1}
If ((X.Y+1)<=X.zH) then
   begin
   Z:=X.Rows[X.Y+1][X.X];
   If NotTransparent or (Not RGBEqual(Z,X.TC)) then
      begin
      R:=R+Integer(Z.R);
      G:=G+Integer(Z.G);
      B:=B+Integer(Z.B);
      d:=d+1;
      end;//end of if
   end;//end of if
{Result}
Z.R:=Byte(R Div D);
Z.G:=Byte(G Div D);
Z.B:=Byte(B Div D);
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,Z);
except;end;
end;
//--------------- New -------------------
//## ppRGBAdjust ##
Procedure ppRGBAdjust(Var X:TPixelInfo);
Var
   R,G,B:Integer;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
{Red}
If (X.aR<>0) and ((X.Style=1) or ((X.Style=0) and (X.T.R<>0))) then
   begin
   R:=Integer(X.T.R)+(X.aR*255 Div 100);
   If (R<0) then R:=0 else if (R>255) then R:=255;
   X.T.R:=Byte(R);
   end;//end of if
{Green}
If (X.aG<>0) and ((X.Style=1) or ((X.Style=0) and (X.T.G<>0))) then
   begin
   G:=Integer(X.T.G)+(X.aG*255 Div 100);
   If (G<0) then G:=0 else if (G>255) then G:=255;
   X.T.G:=Byte(G);
   end;//end of if
{Blue}
If (X.aB<>0) and ((X.Style=1) or ((X.Style=0) and (X.T.B<>0))) then
   begin
   B:=Integer(X.T.B)+(X.aB*255 Div 100);
   If (B<0) then B:=0 else if (B>255) then B:=255;
   X.T.B:=Byte(B);
   end;//end of if
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppBrightnessContrast ##
Procedure ppBrightnessContrast(Var X:TPixelInfo);
Label
     SkipOne;
Var
   L,C,P,R,G,B:Integer;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
{Split into R,G,B}
R:=Integer(X.T.R);
G:=Integer(X.T.G);
B:=Integer(X.T.B);
{Brightness}
If (X.aR<>0) then
   begin
   R:=R+(X.aR*255 Div 100);
   G:=G+(X.aR*255 Div 100);
   B:=B+(X.aR*255 Div 100);
   SafeRGB(R,G,B);
   end;//end of if
{Contrast}
//-100..-1%
If (X.aG<0) then
   begin
   P:=-X.aG;
   C:=(127*P Div 100);
   R:=(R*(100-P) Div 100)+C;
   G:=(G*(100-P) Div 100)+C;
   B:=(B*(100-P) Div 100)+C;
   end
//1..100%
else If (X.aG>0) then
   begin
   P:=X.aG;
   {Luminance}
   L:=MaxRGB(X.T.R,X.T.G,X.T.B);
   If (L=0) or (L=255) then Goto SkipOne;
   If (R>128) then R:=R+(255-R)*P Div 100 else R:=R+(-R*P) Div 100;
   If (G>128) then G:=G+(255-G)*P Div 100 else G:=G+(-G*P) Div 100;
   If (B>128) then B:=B+(255-B)*P Div 100 else B:=B+(-B*P) Div 100;
   end;//end of if
SkipOne:
{SafeRGB}
SafeRGB(R,G,B);
{ReCombine}
X.T.R:=Byte(R);
X.T.G:=Byte(G);
X.T.B:=Byte(B);
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppLuminanceChrominance ##
Procedure ppLuminanceChrominance(Var X:TPixelInfo);
Var
   R,G,B:Integer;
   YUV:TIntTriplet;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
{RGBtoYUV}
Case X.Style of
0:RGBtoYUV(X.T,YUV);
1:RGBtoYIQ(X.T,YUV);
else
 exit;
end;//end of case
{Process}
//Y - Brightness
YUV[0]:=Round(YUV[0]+2.5*X.aR);
//U - Color
YUV[1]:=Round(YUV[1]+2.5*X.aG);
//V - Tint
YUV[2]:=Round(YUV[2]+2.5*X.aB);
{YUVtoRGB}
Case X.Style of
0:YUVtoRGB(YUV,X.T);
1:YIQtoRGB(YUV,X.T);
else
 exit;
end;//end of case
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppPosterize ##
Procedure ppPosterize(Var X:TPixelInfo);
Var
   P:Integer;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
{Set Temp Variables}
If Not X.atSet then
   begin
   X.atR:=Round(Power(2,X.aR))-1;
   X.atG:=Round(Power(2,X.aG))-1;
   X.atB:=Round(Power(2,X.aB))-1;
   {Once Only}
   X.atSet:=True;
   end;//end of if
{Process}
X.T.R:=Posterize(X.T.R,X.atR);
X.T.G:=Posterize(X.T.G,X.atG);
X.T.B:=Posterize(X.T.B,X.atB);
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppSolarize ##
Procedure ppSolarize(Var X:TPixelInfo);
Var
   L:Integer;
   CYM:TColor24;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
{Process}
Case X.Style of
0:begin
 If (X.T.R>X.aR) then X.T.R:=255-X.T.R;
 If (X.T.G>X.aR) then X.T.G:=255-X.T.G;
 If (X.T.B>X.aR) then X.T.B:=255-X.T.B;
 end;//end of case
1:If (LumRGB(X.T.R,X.T.G,X.T.B)>X.aR) then
    begin
    X.T.R:=255-X.T.R;
    X.T.G:=255-X.T.G;
    X.T.B:=255-X.T.B;
    end;//end of if
end;//end of case
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppColorize ##
Procedure ppColorize(Var X:TPixelInfo);
Var
   L:Integer;
   HSV:TIntTriplet;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
{Luminance}
{Split into R,G,B}
L:=MaxRGB(X.T.R,X.T.G,X.T.B);
If (X.aB<>0) then L:=L+(X.aB*255 Div 100);
If (L<0) then L:=0 else if (L>255) then L:=255;
{Prepare HSV}
HSV[0]:=X.aR;
HSV[1]:=X.aG;
HSV[2]:=L;
{HSVtoRGB}
HSVtoRGB(HSV,X.T);
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppGreyScale ##
Procedure ppGreyScale(Var X:TPixelInfo);
Var
   Y:Byte;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
//Get
Case X.Style of
0:Y:=LumRGB(X.T.R,X.T.G,X.T.B);
1:Y:=Byte((Integer(X.T.R)*3+Integer(X.T.G)*2+Integer(X.T.B)) Div 6);
2:Y:=Byte((Integer(X.T.G)*3+Integer(X.T.B)*2+Integer(X.T.R)) Div 6);
3:Y:=Byte((Integer(X.T.B)*3+Integer(X.T.R)*2+Integer(X.T.G)) Div 6);
end;//end of case
//Form Color
X.T.R:=Y;
X.T.G:=Y;
X.T.B:=Y;
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//--------------- End of New ------------
//## ppColor ##
Procedure ppColor(Var X:TPixelInfo);
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Process}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.A);
except;end;
end;
//## ppEraser ##
Procedure ppEraser(Var X:TPixelInfo);
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Process}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.B);
except;end;
end;
//## ppReplace ##
Procedure ppReplace(Var X:TPixelInfo);
Var
   D:Integer;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Process}
D:=150*X.Strength Div 100;{Med. Strengths}
X.T:=X.Rows[X.Y][X.X];
If (X.T.R<=(X.A.R+D)) and (X.T.R>=(X.A.R-D)) and (X.T.G<=(X.A.G+D)) and (X.T.G>=(X.A.G-D)) and (X.T.B<=(X.A.B+D)) and (X.T.B>=(X.A.B-D)) then X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.B);
except;end;
end;
//## ppReplaceShades ##
Procedure ppReplaceShades(Var X:TPixelInfo);
Var
   b1,b2,b3:Integer;
   D,R,G,B:Integer;
begin
try{d=8 atleast for 16bit color detection}
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Process}
D:=(150*X.Strength) Div 100;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
If Not ((X.T.R<=(X.A.R+D)) and (X.T.R>=(X.A.R-D)) and (X.T.G<=(X.A.G+D)) and (X.T.G>=(X.A.G-D)) and (X.T.B<=(X.A.B+D)) and (X.T.B>=(X.A.B-D))) then exit;
{b1}
b1:=X.A.R;
If (X.A.G>b1) then b1:=X.A.G;
If (X.A.B>b1) then b1:=X.A.B;
{b2}
b2:=X.T.R;
If (X.T.G>b2) then b2:=X.T.G;
If (X.T.B>b2) then b2:=X.T.B;
{b1,b2}
b3:=b1-b2;
{Process}
{R,G,B}
R:=Integer(X.B.R)-b3;If (R<0) then R:=0 else if R>255 then R:=255;
G:=Integer(X.B.G)-b3;If (G<0) then G:=0 else if G>255 then G:=255;
B:=Integer(X.B.B)-b3;If (B<0) then B:=0 else if B>255 then B:=255;
{Write}
X.T.R:=Byte(R);
X.T.G:=Byte(G);
X.T.B:=Byte(B);
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppRandom ##
Procedure ppRandomColor(Var X:TPixelInfo);
Var
   D2,D,A:Integer;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Process}
D:=(101-X.Strength) Div 2;{Inverted Med. Strengths}
D2:=D+1;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
{Write}
X.T.R:=Byte((Integer(X.T.R)*D+Random(256)) Div D2);
X.T.G:=Byte((Integer(X.T.G)*D+Random(256)) Div D2);
X.T.B:=Byte((Integer(X.T.B)*D+Random(256)) Div D2);
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppInvert ##
Procedure ppInvert(Var X:TPixelInfo);
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
{Process}
Case X.Style of
0:begin
  X.T.R:=255-X.T.R;
  X.T.G:=255-X.T.G;
  X.T.B:=255-X.T.B;
  end;//end of begin
1:X.T.R:=255-X.T.R;
2:X.T.G:=255-X.T.G;
3:X.T.B:=255-X.T.B;
end;//end of begin
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppRemove ##
Procedure ppRemove(Var X:TPixelInfo);
Var
   D,C:Integer;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
{Process}
D:=255*X.Strength Div 100;
Case X.Style of
0,1:begin
   C:=Integer(X.T.R)-D;
   If (C<0) then C:=0;
   X.T.R:=Byte(C);
   end;//end of begin
2:begin
   C:=Integer(X.T.G)-D;
   If (C<0) then C:=0;
   X.T.G:=Byte(C);
   end;//end of begin
3:begin
   C:=Integer(X.T.B)-D;
   If (C<0) then C:=0;
   X.T.B:=Byte(C);
   end;//end of begin
end;//end of case
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppShades ##
Procedure ppShades(Var X:TPixelInfo);
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
{Process}
Case X.Style of
0,1:begin
   X.T.G:=0;
   X.T.B:=0;
   end;//end of begin
2:begin
   X.T.R:=0;
   X.T.B:=0;
   end;//end of begin
3:begin
   X.T.R:=0;
   X.T.G:=0;
   end;//end of begin
end;//end of case
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppMonoChrome ##
Procedure ppMonoChrome(Var X:TPixelInfo);
Var
   Y:Byte;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
{Ignore if already black/white}
If (X.T.R=0) and (X.T.G=0) and (X.T.B=0) then exit;
If (X.T.R=255) and (X.T.G=255) and (X.T.B=255) then exit;
//Get
Case X.Style of
0:Y:=Byte((Integer(X.T.R)+Integer(X.T.G)+Integer(X.T.B)) Div 3);
1:Y:=X.T.R;
2:Y:=X.T.G;
3:Y:=X.T.B;
end;//end of case
//Generate Color
If (Y<127) then Y:=0 else Y:=255;
X.T.R:=Y;
X.T.G:=Y;
X.T.B:=Y;
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppBlend ##
Procedure ppBlend(Var X:TPixelInfo);
Var
   D2,D:Integer;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Process}
D:=(101-X.Strength) Div 2;{Inverted Med. Strengths}
D2:=D+1;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
//Generate Color
X.T.R:=Byte((Integer(X.T.R)*D+Integer(X.A.R)) Div D2);
X.T.G:=Byte((Integer(X.T.G)*D+Integer(X.A.G)) Div D2);
X.T.B:=Byte((Integer(X.T.B)*D+Integer(X.A.B)) Div D2);
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppMerge ##
Procedure ppMerge(Var X:TPixelInfo);
Var
   D,iR,iG,iB:Integer;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Process}
D:=X.Strength Div 2;
If (D<=0) then exit;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
{Red}
iR:=255-D;
X.T.R:=Byte((X.T.R*iR+X.A.R*D) div 255);
{Green}
iG:=255-D;
X.T.G:=Byte((X.T.G*iG+X.A.G*D) div 255);
{Blue}
iB:=255-D;
X.T.B:=Byte((X.T.B*iB+X.A.B*D) div 255);
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppVerticalStripe ##
Procedure ppVerticalStripe(Var X:TPixelInfo);
Var
   A:TPixelInfo;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Process}
A:=X;
If (((X.X Div 2)*2)<>X.X) then A.A:=X.B;
ppMerge(A);
except;end;
end;
//## ppHorizontalStripe ##
Procedure ppHorizontalStripe(Var X:TPixelInfo);
Var
   A:TPixelInfo;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Process}
A:=X;
If (((X.Y Div 2)*2)<>X.Y) then A.A:=X.B;
ppMerge(A);
except;end;
end;
//## ppLighten ##
Procedure ppLighten(Var X:TPixelInfo);
Var
   C,D:Integer;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Process}
D:=X.Strength Div 2;{Low Strengths}
{Get Color}
X.T:=X.Rows[X.Y][X.X];
{Generate Color}
//Red
If (X.Style<=1) and (X.T.R<255) then
   begin
   C:=Integer(X.T.R)+D;
   If (C>255) then C:=255;
   X.T.R:=Byte(C);
   end;//end of if
//Green
If ((X.Style=0) or (X.Style=2)) and (X.T.G<255) then
   begin
   C:=Integer(X.T.G)+D;
   If (C>255) then C:=255;
   X.T.G:=Byte(C);
   end;//end of if
//Blue
If ((X.Style=0) or (X.Style=3)) and (X.T.B<255) then
   begin
   C:=Integer(X.T.B)+D;
   If (C>255) then C:=255;
   X.T.B:=Byte(C);
   end;//end of if
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppDarken ##
Procedure ppDarken(Var X:TPixelInfo);
Var
   C,D:Integer;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Process}
D:=X.Strength Div 2;{Low Strengths}
{Get Color}
X.T:=X.Rows[X.Y][X.X];
{Generate Color}
//Red
If (X.Style<=1) and (X.T.R>0) then
   begin
   C:=Integer(X.T.R)-D;
   If (C<0) then C:=0;
   X.T.R:=C;
   end;//end of if
//Green
If ((X.Style=0) or (X.Style=2)) and (X.T.G>0) then
   begin
   C:=Integer(X.T.G)-D;
   If (C<0) then C:=0;
   X.T.G:=C;
   end;//end of if
//Blue
If ((X.Style=0) or (X.Style=3)) and (X.T.B>0) then
   begin
   C:=Integer(X.T.B)-D;
   If (C<0) then C:=0;
   X.T.B:=C;
   end;//end of if
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppPlasma ##
Procedure ppPlasma(Var X:TPixelInfo);
Var
   rA,gA,bA,A:Integer;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
{Red}
Case X.Style of
0:begin
    rA:=105;
    gA:=100;
    bA:=95;
    end;//end of begin
1:begin
    rA:=105;
    gA:=43;
    bA:=12;
    end;//end of begin
2:begin
    gA:=105;
    bA:=43;
    rA:=12;
    end;//end of begin
3:begin
    bA:=105;
    rA:=43;
    gA:=12;
    end;//end of begin
end;//end of case
{Process}
A:=Integer(X.T.R)+rA;
If (A>255) then A:=A-256;
X.T.R:=Byte(A);
{Green}
A:=Integer(X.T.G)+gA;
If (A>255) then A:=A-256;
X.T.G:=Byte(A);
{Blue}
A:=Integer(X.T.B)+bA;
If (A>255) then A:=A-256;
X.T.B:=Byte(A);
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;
//## ppHotCold ##
Procedure ppHotCold(Var X:TPixelInfo);
Var
   R,G,B:Byte;
   V:Integer;
begin
try
{Scatter Decision}
If Not ppdScatter(X) then exit;
{Get Color}
X.T:=X.Rows[X.Y][X.X];
{Get Brightness}
V:=X.T.R;
If (X.T.G>V) then V:=X.T.G;
If (X.T.B>V) then V:=X.T.B;
{Convert to HotCold}
Case V of
0..63:begin{25%}
     R:=0;
     G:=4*V;
     B:=255;{*}
     end;//end of begin
64..127:begin{50%}
     R:=0;
     G:=255;{*}
     B:=255+4*(64-V);
     end;//end of begin
128..191:begin{75%}
     R:=255+4*(128-V);
     G:=255;{*}
     B:=0;
     end;//end of begin
192..255:begin
     R:=255;{*}
     G:=255+4*(192-V);
     B:=0;
     end;//end of begin
end;//end of case
{Form Color}
X.T.R:=Byte(R);
X.T.G:=Byte(G);
X.T.B:=Byte(B);
{Set Color}
X.Rows[X.Y][X.X]:=ppdSafeColor(X,X.T);
except;end;
end;

//######################### TPenShapeRef #######################################
//## WithinPen ##
Function WithinPen(Var Z:TPenRef;X,Y:Integer):Boolean;
begin
try
{No}
Result:=False;
if (Y<Z.minY) or (Y>Z.maxY) then exit;
{Result}
Result:=(X>=Z.rowY[byte(Y)][0]) and (X<=Z.rowY[byte(Y)][1]);
except;end;
end;
//## FillPen ##
Function FillPen(Var X:TBitmap;Var Y:TPenRef):Boolean;
Var
   Row:PRGBColorRow;
   P,rX,rY:Integer;
   Z:TColor24;
   minyOk:Boolean;
begin
try
{Error}
Result:=False;
If (X=nil) or (X.Width=0) or (X.Height=0) then exit;
{Scan Color}
Z.R:=0;
Z.G:=0;
Z.B:=0;
{X}
X.PixelFormat:=pf24bit;
Y.Width:=X.Width;
Y.Height:=FrcRange(X.Height,0,High(Y.rowY)+1);
{Dimension Information}
Y.ZeroWidth:=Y.Width-1;
Y.ZeroHeight:=Y.Height-1;
Y.HalfWidth:=Y.Width Div 2;
Y.HalfHeight:=Y.Height Div 2;
{Defaults}
Y.minY:=0;
Y.maxY:=-1;
Y.area:=0;
minyOk:=True;
{Scan}
For rY:=0 to Y.ZeroHeight Do
begin
Row:=X.Scanline[rY];
//Left
P:=StartX(Row,Z,0,Y.ZeroWidth);{blank line = "0,-1"}
If (P<0) then P:=0;
Y.rowY[rY][0]:=P;
//Right
P:=FinishX(Row,Z,0,Y.ZeroWidth);
Y.rowY[rY][1]:=P;
//Increment Area
Y.area:=Y.area+(Y.rowY[rY][1]-Y.rowY[rY][0]+1);
//Y Range
If (P<>-1) then
   begin
   //minY
   If minyOk then
      begin
      minyOk:=False;
      Y.minY:=rY;
      end;//end of if
   //maxY
   Y.maxY:=rY;
   end;//end of if
end;//end of loop
{Y.area=0}
If (Y.area=0) then
   begin
   Y.area:=1;
   Y.minY:=Y.HalfHeight;
   Y.maxY:=Y.HalfHeight;
   Y.rowY[Y.minY][0]:=Y.HalfWidth;
   Y.rowY[Y.minY][1]:=Y.HalfWidth;
   end;//end of if
{Successful}
Result:=True;
except;end;
end;
//## StartX ##
Function StartX(X:PRGBColorRow;Y:TColor24;S,F:Integer):Integer;
Var
   P:Integer;
   Z:TColor24;
begin
try
{Error/Not Found}
Result:=-1;
{Scan}
For P:=S to F Do
begin
Z:=X[P];
If (Z.R=Y.R) and (Z.G=Y.G) and (Z.B=Y.B) then
   begin
   Result:=P;
   break;
   end;//end of if
end;//end of if
except;end;
end;
//## FinishX ##
Function FinishX(X:PRGBColorRow;Y:TColor24;S,F:Integer):Integer;
Var
   P:Integer;
   Z:TColor24;
begin
try
{Error/Not Found}
Result:=-1;
{Scan}
For P:=F downTo S Do
begin
Z:=X[P];
If (Z.R=Y.R) and (Z.G=Y.G) and (Z.B=Y.B) then
   begin
   Result:=P;
   break;
   end;//end of if
end;//end of if
except;end;
end;

//########################### TBrushMapRef #####################################
//## FillBrush ##
Function FillBrush(Var X:TBitmap;Var Y:TBrushRef):Boolean;
Var
   Row:PRGBColorRow;
   P,rX,rY:Integer;
   C:Byte;
   Zr,Z:TColor24;
   minyOk:Boolean;
begin
try
{Error}
Result:=False;
If (X=nil) or (X.Width=0) or (X.Height=0) then exit;
{Scan Color}
Z.R:=0;
Z.G:=0;
Z.B:=0;
{X}
X.PixelFormat:=pf24bit;
Y.Width:=FrcRange(X.Width,0,High(Y.Pixels)+1);
Y.Height:=FrcRange(X.Height,0,High(Y.Pixels[0])+1);
{Dimension Information}
Y.ZeroWidth:=Y.Width-1;
Y.ZeroHeight:=Y.Height-1;
Y.HalfWidth:=Y.Width Div 2;
Y.HalfHeight:=Y.Height Div 2;
{Defaults}
Y.minY:=0;
Y.maxY:=-1;
Y.area:=0;
minyOk:=True;
{Scan}
For rY:=0 to Y.ZeroHeight Do
begin
Row:=X.Scanline[rY];
 For rX:=0 to Y.ZeroWidth Do
 begin
 Z:=Row[rX];
{ C:=Z.R;
 If (Z.G>C) then C:=Z.G;
 If (Z.B>C) then C:=Z.B;
{}
 C:=maxRGB(Z.R,Z.G,Z.B);
 Y.Pixels[byte(rY),byte(rX)]:=C;
 If (C<>255) then{255=NO,0-254 Shades of grey}
    begin
    //Increment Area
    Y.area:=Y.area+1;
    //minY
    If minyOk then
        begin
        minyOk:=False;
        Y.minY:=rY;
        end;//end of if
    //maxY
    Y.maxY:=rY;
    end;//end of if
 end;//end of loop
end;//end of loop
{MapX,Y}
rX:=0;
rY:=0;
For P:=0 to High(Y.MapX) Do
begin
//X
Y.MapX[P]:=rX;
rX:=rX+1;
If (rX>Y.ZeroWidth) then rX:=0;
//Y
Y.MapY[P]:=rY;
rY:=rY+1;
If (rY>Y.ZeroHeight) then rY:=0;
end;//end of loop
{Successful}
Result:=True;
except;end;
end;
//## ToByte ##
Function ToByte(Var X:TBitArray):Byte;
begin
try
Result:=0;
If X[0] then Result:=Result+1;
If X[1] then Result:=Result+2;
If X[2] then Result:=Result+4;
If X[3] then Result:=Result+8;
If X[4] then Result:=Result+16;
If X[5] then Result:=Result+32;
If X[6] then Result:=Result+64;
If X[7] then Result:=Result+128;
except;end;
end;
//## FromByte ##
Procedure FromByte(X:Byte;Var Y:TBitArray);
begin
try
If (X>127) then begin;Y[7]:=True;X:=X-128;end else Y[7]:=False;
If (X>63) then begin;Y[6]:=True;X:=X-64;end else Y[6]:=False;
If (X>31) then begin;Y[5]:=True;X:=X-32;end else Y[5]:=False;
If (X>15) then begin;Y[4]:=True;X:=X-16;end else Y[4]:=False;
If (X>7) then begin;Y[3]:=True;X:=X-8;end else Y[3]:=False;
If (X>3) then begin;Y[2]:=True;X:=X-4;end else Y[2]:=False;
If (X>1) then begin;Y[1]:=True;X:=X-2;end else Y[1]:=False;
If (X>0) then Y[0]:=True else Y[0]:=False;
except;end;
end;
//## CountImageColors ##
Function CountImageColors(Var X:TManipulationInfo):Integer;
Var{*Warning: MaxStackSize must be =$01000000, (x10 larger than default}
   Row:PRGBColorRow;
   Z:TColor24;
   A:TColors;
   B:TBitArray;
   bI,C:Byte;
   I,P2,R,rX,rY,MinX,MinY,MaxX,MaxY,P:Integer;
begin
try
{Error}
Result:=-1;
If Not SafeInfo(X) then exit;
X.Image.PixelFormat:=pf24bit;
{Clear}
For P:=0 to csccMax Do A[P]:=0;
{Read Reange}
MinX:=X.Rect.Left;
MaxX:=X.Rect.Right;
MinY:=X.Rect.Top;
MaxY:=X.Rect.Bottom;
{Scan}
For rY:=MinY to MaxY Do
begin
Row:=X.Image.Scanline[rY];
 For rX:=MinX to MaxX Do
 begin
 Z:=Row[Word(rX)];
 P2:=RGB(Z.R,Z.G,Z.B);
 {Array Item}
 I:=P2 Div 8;
 C:=A[I];
 {Array -> BitArray}
 FromByte(C,B);
 bI:=byte(P2-I*8);
 {Not True therefore set}
 If not B[bI] then
    begin
    B[bI]:=True;
    {BitArray -> Byte}
    A[I]:=ToByte(B);
    end;//end of if
 end;//end of loop
end;//end of loop
{Count}
R:=0;
For P:=0 to csccMax Do
begin
If (A[P]<>0) then
   begin
   FromByte(A[P],B);
   For P2:=0 to 7 Do If B[P2] then R:=R+1;
   end;//end of if
end;//end of loop
{Successful}
Result:=R;
except;X.ErrMsg:=gecOutOfMemory;end;
end;
//## CustomiseCursor ##
Procedure CustomiseCursor(X,Y:TCursor;Z:String);
Var
   P:Integer;
begin
try
P:=LoadCursor(hInstance,PChar(Z));
Case (P=0) of
True:If (Y<>crNil) then Screen.Cursors[X]:=Screen.Cursors[Y];
False:Screen.Cursors[X]:=P;
end;//end of case
except;end
end;
//## AlternateGrid8x8 ##
Function AlternateGrid8x8(X:TBitmap;F,B:Integer):Boolean;
Var
   C,rX,rY,MaxX,MaxY:Integer;
   Ok:Boolean;
begin
try
{Error}
Result:=False;
If (X=nil) then exit;
{Dimensions}
MaxX:=X.Width-1;If (MaxX>7) then MaxX:=7;
MaxY:=X.Height-1;If (MaxY>7) then MaxY:=7;
Ok:=True;
For rY:=0 to MaxY Do
begin
 For rX:=0 to MaxX Do
 begin
 Case Ok of
 True:C:=F;
 False:C:=B;
 end;//en dof case
 X.Canvas.Pixels[rX,rY]:=C;
 Ok:=Not Ok;
 end;//end of loop
 Ok:=Not Ok;
end;//end of loop
{Successful}
Result:=True;
except;end;
end;
//## ScrnBits ##
Function ScrnBits:Integer;
Var
   DC:HDC;
begin
try
{Default}
Result:=1;
{Processs}
DC:=GetDC(0);
{Return REsult}
Result:=GetDeviceCaps(DC,BITSPIXEL);
{Free}
ReleaseDC(0,DC);
except;end;
end;
//## ScrnPixelFormat ##
Function ScrnPixelFormat:TPixelFormat;
begin
try
{Return Result}
Case ScrnBits of
1:Result:=pf1bit;
4:Result:=pf4bit;
8:Result:=pf8bit;
15:Result:=pf15bit;
16:Result:=pf16bit;
24:Result:=pf24bit;
32:Result:=pf32bit;
else
 {Default}
 Result:=pf16bit;
end;//end of case
except;end;
end;
//## Stepable ##
Function Stepable(cX,cY,dX,dY,Step:Integer):Boolean;
Var
   rX,rY:Integer;
begin
try
{No}
Result:=False;
{Process}
If (Step<0) then Step:=1;
rX:=dX-cX;If (rX<0) then rX:=-rX;
rY:=dY-cY;If (rY<0) then rY:=-rY;
{Return Result}
Result:=(rX>=Step) or (rY>=Step);
except;end;
end;


initialization
  {Randomize}
  Randomize;
  {Customise/Default Image Cursors - Uses found cursor, or defaults to Supplied 2nd Cursor if 2ndCursor<>crNil}
//xxxxx  {$R IWSCURS.RES}
{
  CustomiseCursor(crCrossHair,crCross,'CrossHair');
  CustomiseCursor(crPencil,crCross,'Pencil');
  CustomiseCursor(crBrush,crCross,'Brush');
  CustomiseCursor(crHand,crHandPoint,'Hand');
  CustomiseCursor(crPotFill,crCross,'PotFill');
  CustomiseCursor(crGlobalPotFill,crCross,'PotFillG');
  CustomiseCursor(crSelect,crCross,'Select');
  CustomiseCursor(crZoom,crArrow,'Zoom');
  CustomiseCursor(crShape,crCross,'Shape');
{}

end.
